<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[MySQL]优化</title>
      <link href="/2026/01/15/MySQL-SQL%E4%BC%98%E5%8C%96/"/>
      <url>/2026/01/15/MySQL-SQL%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="1-插入数据优化-Insert-Optimization"><a href="#1-插入数据优化-Insert-Optimization" class="headerlink" title="1. 插入数据优化 (Insert Optimization)"></a>1. 插入数据优化 (Insert Optimization)</h3><p><strong>核心目标：</strong> 减少磁盘I&#x2F;O交互次数，降低日志刷新频率。</p><ul><li><p>批量插入 (Batch Insert):</p><p>不要使用多条 INSERT INTO 语句，合并为一条。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 推荐</span><br><span class="line">INSERT INTO tb_test VALUES (1,&#x27;a&#x27;), (2,&#x27;b&#x27;), (3,&#x27;c&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>手动事务控制 (Manual Transaction):</p><p>如果插入数据量大（例如几千条），不要让数据库自动提交事务。手动开启事务，执行完后一次提交。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">INSERT ...;</span><br><span class="line">INSERT ...;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure></li><li><p>主键顺序插入:</p><p>数据按照主键顺序插入效率最高，减少由于页分裂 (Page Split) 带来的性能损耗。</p></li><li><p>大批量导入 (Load Data):</p><p>对于百万级以上数据，使用 LOAD DATA INFILE 指令，性能远超 INSERT。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA LOCAL INFILE &#x27;/path/to/data.sql&#x27; INTO TABLE tb_user ...;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">load data local infile &#x27;/root/load_user_100w_sort.sql&#x27; into table tb_user fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27;;</span><br><span class="line">-- fields terminated by &#x27;,&#x27;是每个数据以&#x27;,&#x27;进行分割</span><br><span class="line">-- lines terminated by &#x27;\n&#x27;是每行数据以换行符进行分割</span><br><span class="line">-- 具体分割方式依照要导入的数据排列方式而定</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="2-主键优化-Primary-Key-Optimization"><a href="#2-主键优化-Primary-Key-Optimization" class="headerlink" title="2. 主键优化 (Primary Key Optimization)"></a>2. 主键优化 (Primary Key Optimization)</h3><p><strong>核心目标：</strong> 维护B+树结构的稳定，减少空间浪费。</p><ul><li><strong>主键长度:</strong> 越短越好。二级索引的叶子节点存储的是主键值，主键越长，二级索引占用空间越大，IO效率越低。</li><li><strong>自增主键 (Auto-increment):</strong> 强烈建议使用自增ID。<ul><li><strong>优势:</strong> 顺序写入，数据直接追加到当前页，写满申请新页。</li><li><strong>避免:</strong> 尽量避免使用 UUID 做主键。UUID 无序且长，会导致频繁的<strong>页分裂</strong>（Page Split）和<strong>页合并</strong>，造成大量的磁盘随机IO和碎片。</li></ul></li><li><strong>避免修改主键:</strong> 修改主键相当于删除旧记录+插入新记录，代价极高。</li></ul><hr><h3 id="3-Order-By-优化"><a href="#3-Order-By-优化" class="headerlink" title="3. Order By 优化"></a>3. Order By 优化</h3><p><strong>核心目标:</strong> 使用 <code>Using index</code> (索引排序)，避免 <code>Using filesort</code> (文件排序)。</p><ul><li><strong>全值匹配&#x2F;最左前缀:</strong> 排序字段必须符合索引的最左前缀法则。</li><li><strong>覆盖索引:</strong> <code>SELECT</code> 的字段和 <code>ORDER BY</code> 的字段最好都能包含在索引中，避免回表查询。</li><li><strong>升降序一致性:</strong><ul><li>索引默认为 ASC。如果查询 <code>ORDER BY a ASC, b DESC</code>，在 MySQL 8.0 之前会导致 Filesort。</li><li><strong>优化:</strong> 创建联合索引时直接指定排序规则: <code>CREATE INDEX idx_a_b ON table(a ASC, b DESC);</code></li></ul></li><li><strong>Filesort 兜底:</strong> 如果不得不发生 Filesort，且数据量大，尝试增加 <code>sort_buffer_size</code> 参数，避免使用磁盘临时文件进行排序。</li></ul><hr><h3 id="4-Group-By-优化"><a href="#4-Group-By-优化" class="headerlink" title="4. Group By 优化"></a>4. Group By 优化</h3><p><strong>核心目标:</strong> 利用索引结构直接分组，避免创建临时表。</p><ul><li><strong>索引法则:</strong> 与 Order By 一致，严格遵循最左前缀法则。</li><li><strong>Where 优于 Having:</strong> 能在分组前通过 <code>WHERE</code> 过滤掉的数据，尽量不要留到 <code>HAVING</code> 中过滤。减少参与分组计算的数据量是第一原则。</li></ul><hr><h3 id="5-Limit-优化-分页优化"><a href="#5-Limit-优化-分页优化" class="headerlink" title="5. Limit 优化 (分页优化)"></a>5. Limit 优化 (分页优化)</h3><p><strong>核心目标:</strong> 解决深度分页（Deep Pagination）时的全表扫描问题。</p><p><strong>问题场景:</strong> <code>LIMIT 2000000, 10</code>。MySQL 需要排序并读取前 2,000,010 条记录，丢弃前 200万条，仅返回最后 10 条。</p><ul><li><p>方案一：覆盖索引 + 子查询 (推荐)</p><p>先在索引中快速找到对应的 ID（避免回表），然后再通过 ID 关联主表获取详情。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 优化前</span><br><span class="line">SELECT * FROM tb_sku LIMIT 2000000, 10;</span><br><span class="line"></span><br><span class="line">-- 优化后</span><br><span class="line">SELECT t.* FROM tb_sku t,</span><br><span class="line">(SELECT id FROM tb_sku ORDER BY id LIMIT 2000000, 10) a</span><br><span class="line">WHERE t.id = a.id;</span><br></pre></td></tr></table></figure></li><li><p>方案二：锚点定位 (适用连续ID)</p><p>如果ID是连续的且可以推断，直接用 Where 过滤。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tb_sku WHERE id &gt; 2000000 LIMIT 10;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="6-Count-优化"><a href="#6-Count-优化" class="headerlink" title="6. Count 优化"></a>6. Count 优化</h3><p><strong>核心目标:</strong> 了解不同 Count 写法的性能差异 (InnoDB 引擎)。</p><ul><li><strong>性能排序:</strong> <code>count(*) ≈ count(1) &gt; count(主键) &gt; count(字段)</code></li><li><strong>原理区别:</strong><ul><li><strong>count(字段):</strong> 会遍历全表，<strong>不计算 NULL 值</strong>。如果字段没有 <code>NOT NULL</code> 约束，还要一行行判断是否为 NULL，最慢。</li><li><strong>count(主键):</strong> 遍历全表，取出主键，累加。</li><li><strong>count(*):</strong> MySQL 做了专门优化，不取值，直接按行累加。InnoDB 会自动选择最小的二级索引进行遍历（成本最低）。</li></ul></li><li><strong>建议:</strong> 总是使用 <code>count(*)</code>。</li><li><strong>超大数据量:</strong> 如果需要频繁查询千万级数据的总数且允许微小误差，使用 <code>EXPLAIN</code> 的 <code>rows</code> 值估算；要求精确则需自己在 Redis 或计数表中维护计数。</li></ul><hr><h3 id="7-Update-优化"><a href="#7-Update-优化" class="headerlink" title="7. Update 优化"></a>7. Update 优化</h3><p><strong>核心目标:</strong> 避免<strong>行锁 (Row Lock)</strong> 升级为 <strong>表锁 (Table Lock)</strong>。</p><ul><li><p><strong>索引是关键:</strong> InnoDB 的行锁是加在<strong>索引</strong>上的，而不是加在记录上的。</p></li><li><p><strong>必须走索引:</strong></p><ul><li>如果 <code>UPDATE</code> 语句的 <code>WHERE</code> 条件字段<strong>建立了索引</strong>，InnoDB 会锁定对应的行（行锁），并发性能好。</li><li>如果 <code>WHERE</code> 条件字段<strong>没有索引</strong>（或索引失效），InnoDB 将被迫锁住整张表（表锁），导致其他事务无法操作该表，严重阻塞业务。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 假设 name 字段没有索引</span><br><span class="line">-- 这条语句会锁住整张表！</span><br><span class="line">UPDATE student SET name = &#x27;NewName&#x27; WHERE name = &#x27;OldName&#x27;;</span><br></pre></td></tr></table></figure></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MySQL]索引</title>
      <link href="/2026/01/15/MySQL-%E7%B4%A2%E5%BC%95/"/>
      <url>/2026/01/15/MySQL-%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-索引核心知识体系总结"><a href="#MySQL-索引核心知识体系总结" class="headerlink" title="MySQL 索引核心知识体系总结"></a>MySQL 索引核心知识体系总结</h1><h2 id="1-索引概述"><a href="#1-索引概述" class="headerlink" title="1. 索引概述"></a>1. 索引概述</h2><ul><li><strong>定义</strong>：索引（Index）是帮助 MySQL <strong>高效获取数据</strong>的数据结构（有序）。</li><li><strong>本质</strong>：空间换时间。</li><li><strong>优缺点</strong>：<ul><li><strong>优点</strong>：<ol><li>大大减少服务器扫描的数据量（降低 I&#x2F;O 成本）。</li><li>帮助服务器避免排序和临时表（降低 CPU 成本）。</li></ol></li><li><strong>缺点</strong>：<ol><li>占用磁盘空间。</li><li>降低写操作（<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>）的速度，因为需要维护索引结构。</li></ol></li></ul></li></ul><h2 id="2-索引结构-InnoDB"><a href="#2-索引结构-InnoDB" class="headerlink" title="2. 索引结构 (InnoDB)"></a>2. 索引结构 (InnoDB)</h2><p>MySQL 默认存储引擎 InnoDB 使用 <strong>B+ Tree</strong> 结构。</p><ul><li><strong>B+ Tree 特点</strong>：<ol><li><strong>非叶子节点</strong>仅存储键值（Key）和指针，不存储数据，增加了节点的度（Fan-out），树的高度通常控制在 3-4 层，减少 I&#x2F;O 次数。</li><li><strong>叶子节点</strong>存储所有数据（Key + Row Data 或 Key + PK），且叶子节点之间通过<strong>双向链表</strong>连接。</li><li><strong>扫库方便</strong>：支持范围查询，全表扫描只需遍历叶子节点链表。</li></ol></li><li><strong>为什么不用其他结构？</strong><ul><li><strong>Hash</strong>：仅支持精确匹配（<code>=</code>），不支持范围查询（<code>&gt;</code>, <code>&lt;</code>），不支持排序。</li><li><strong>二叉树&#x2F;红黑树</strong>：大数据量下树太高，磁盘 I&#x2F;O 次数过多；可能会退化成链表（二叉树）。</li><li><strong>B-Tree</strong>：非叶子节点也存数据，导致单页存储的 Key 变少，树的高度变高，I&#x2F;O 增加。</li></ul></li></ul><h2 id="3-索引分类"><a href="#3-索引分类" class="headerlink" title="3. 索引分类"></a>3. 索引分类</h2><h3 id="3-1-按物理存储分类-InnoDB-核心"><a href="#3-1-按物理存储分类-InnoDB-核心" class="headerlink" title="3.1 按物理存储分类 (InnoDB 核心)"></a>3.1 按物理存储分类 (InnoDB 核心)</h3><table><thead><tr><th><strong>分类</strong></th><th><strong>聚集索引 (Clustered Index)</strong></th><th><strong>二级索引 (Secondary Index)</strong></th></tr></thead><tbody><tr><td><strong>存储内容</strong></td><td>叶子节点存储<strong>完整行数据</strong></td><td>叶子节点存储<strong>索引列值 + 主键值</strong></td></tr><tr><td><strong>数量</strong></td><td>有且仅有一个</td><td>可以有多个</td></tr><tr><td><strong>选取规则</strong></td><td>1. 主键 (Primary Key) 2. 第一个唯一非空索引 (Unique Not Null) 3. 自动生成隐藏列 ROW_ID</td><td>除了聚集索引外的所有索引</td></tr><tr><td><strong>回表查询</strong></td><td>不需要</td><td>需要（先查二级索引拿到主键，再回聚集索引查数据），除非<strong>覆盖索引</strong></td></tr></tbody></table><h3 id="3-2-按逻辑-功能分类"><a href="#3-2-按逻辑-功能分类" class="headerlink" title="3.2 按逻辑&#x2F;功能分类"></a>3.2 按逻辑&#x2F;功能分类</h3><ul><li><strong>主键索引 (Primary)</strong>：唯一且非空。</li><li><strong>唯一索引 (Unique)</strong>：索引列值必须唯一，允许 NULL。</li><li><strong>普通索引 (Normal)</strong>：无特殊限制。</li><li><strong>全文索引 (Fulltext)</strong>：用于大文本搜索（通常用 ES 替代）。</li></ul><h3 id="3-3-按字段个数分类"><a href="#3-3-按字段个数分类" class="headerlink" title="3.3 按字段个数分类"></a>3.3 按字段个数分类</h3><ul><li><strong>单列索引</strong>：一个索引包含一个列。</li><li><strong>联合索引</strong>：一个索引包含多个列（涉及最左前缀原则）。</li></ul><h2 id="4-索引相关语法"><a href="#4-索引相关语法" class="headerlink" title="4. 索引相关语法"></a>4. 索引相关语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 创建索引</span><br><span class="line">CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (col_name [ASC|DESC], ...);</span><br><span class="line"></span><br><span class="line">-- 查看索引</span><br><span class="line">SHOW INDEX FROM table_name;</span><br><span class="line"></span><br><span class="line">-- 删除索引</span><br><span class="line">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure><h2 id="5-SQL-性能分析工具"><a href="#5-SQL-性能分析工具" class="headerlink" title="5. SQL 性能分析工具"></a>5. SQL 性能分析工具</h2><h3 id="5-1-SQL-执行频率"><a href="#5-1-SQL-执行频率" class="headerlink" title="5.1 SQL 执行频率"></a>5.1 SQL 执行频率</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GLOBAL STATUS LIKE &#x27;Com_______&#x27;;</span><br></pre></td></tr></table></figure><ul><li>查看 <code>Com_select</code>, <code>Com_insert</code>, <code>Com_update</code>, <code>Com_delete</code> 的数值，判断系统是读多写少还是写多读少，决定优化方向。</li></ul><h3 id="5-2-慢查询日志-Slow-Query-Log"><a href="#5-2-慢查询日志-Slow-Query-Log" class="headerlink" title="5.2 慢查询日志 (Slow Query Log)"></a>5.2 慢查询日志 (Slow Query Log)</h3><ul><li><strong>作用</strong>：记录执行时间超过 <code>long_query_time</code>（默认 10s）的 SQL。</li><li><strong>配置</strong>：<code>/etc/my.cnf</code> 中设置 <code>slow_query_log=1</code> 和 <code>long_query_time=2</code> (示例)。</li><li><strong>分析</strong>：定位出拖慢系统的具体 SQL 语句。</li></ul><h3 id="5-3-Profile-详情"><a href="#5-3-Profile-详情" class="headerlink" title="5.3 Profile 详情"></a>5.3 Profile 详情</h3><ul><li><strong>作用</strong>：查看 SQL 执行在每一个阶段（CPU、IO、Context Switch）的耗时。</li><li><strong>命令</strong>：<ul><li><code>SET profiling = 1;</code> (开启)</li><li><code>SHOW PROFILES;</code> (查看最近 SQL 列表)</li><li><code>SHOW PROFILE FOR QUERY query_id;</code> (查看具体资源消耗)</li></ul></li></ul><h3 id="5-4-EXPLAIN-执行计划-核心"><a href="#5-4-EXPLAIN-执行计划-核心" class="headerlink" title="5.4 EXPLAIN 执行计划 (核心)"></a>5.4 EXPLAIN 执行计划 (核心)</h3><p>使用 <code>EXPLAIN SELECT ...</code> 分析查询。关注核心字段：</p><ol><li><strong>type (访问类型)</strong>：性能由好到差排序：<ul><li><code>NULL</code> (不查表)</li><li><code>system</code> (系统表 1 行)</li><li><code>const</code> (主键&#x2F;唯一索引等值查询)</li><li><code>eq_ref</code> (主键&#x2F;唯一索引关联)</li><li><code>ref</code> (非唯一索引等值查询)</li><li><code>range</code> (索引范围查询)</li><li><code>index</code> (全索引扫描)</li><li><code>all</code> (全表扫描)</li><li><strong>目标</strong>：至少达到 <code>range</code>，最好是 <code>ref</code>。</li></ul></li><li><strong>possible_keys</strong>：可能用到的索引。</li><li><strong>key</strong>：实际用到的索引。</li><li><strong>key_len</strong>：索引使用的字节数（越短越好，用于检查联合索引是否完全生效）。</li><li><strong>Extra</strong>：<ul><li><code>Using index</code>：<strong>好</strong>。使用了覆盖索引，无需回表。</li><li><code>Using where</code>：需要过滤。</li><li><code>Using temporary</code>：<strong>差</strong>。使用了临时表（常见于 group by）。</li><li><code>Using filesort</code>：<strong>差</strong>。需要文件排序（常见于 order by 未命中索引）。</li></ul></li></ol><h2 id="6-索引的使用与失效场景"><a href="#6-索引的使用与失效场景" class="headerlink" title="6. 索引的使用与失效场景"></a>6. 索引的使用与失效场景</h2><h3 id="6-1-最左前缀法则-联合索引"><a href="#6-1-最左前缀法则-联合索引" class="headerlink" title="6.1 最左前缀法则 (联合索引)"></a>6.1 最左前缀法则 (联合索引)</h3><ul><li>查询从索引的<strong>最左列</strong>开始，<strong>不能跳过</strong>索引中的列。</li><li>如果跳过某一列，后面的列索引失效。</li><li><strong>范围查询右侧失效</strong>：如果遇到范围查询 (<code>&gt;</code>, <code>&lt;</code>)，则<strong>该列之后</strong>的列索引失效。（<code>&gt;=</code>、<code>&lt;=</code> 通常不会失效）。</li></ul><h3 id="6-2-常见索引失效情况"><a href="#6-2-常见索引失效情况" class="headerlink" title="6.2 常见索引失效情况"></a>6.2 常见索引失效情况</h3><ol><li><strong>函数运算</strong>：<code>WHERE substring(name, 1, 2) = &#39;ab&#39;</code>（对索引列做运算）。</li><li><strong>字符串不加引号</strong>：<code>WHERE phone = 123</code>（发生隐式类型转换）。</li><li><strong>模糊查询</strong>：<code>LIKE &#39;%abc&#39;</code>（头部模糊匹配失效，<code>&#39;abc%&#39;</code> 走索引）。</li><li><strong>OR 连接</strong>：<code>OR</code> 两侧只要有一侧没有索引，涉及的索引全部失效。</li><li><strong>数据分布影响</strong>：如果 MySQL 评估全表扫描比走索引快（例如表中绝大多数数据都符合条件），则放弃索引。</li></ol><h3 id="6-3-覆盖索引-Covering-Index"><a href="#6-3-覆盖索引-Covering-Index" class="headerlink" title="6.3 覆盖索引 (Covering Index)"></a>6.3 覆盖索引 (Covering Index)</h3><ul><li><strong>定义</strong>：查询的列 (<code>SELECT</code> 后的列) 刚好都在索引中，不需要回表查询。</li><li><strong>建议</strong>：尽量避免 <code>SELECT *</code>，指定必要列，争取命中覆盖索引（Extra: <code>Using index</code>）。</li></ul><h3 id="6-4-前缀索引"><a href="#6-4-前缀索引" class="headerlink" title="6.4 前缀索引"></a>6.4 前缀索引</h3><ul><li>针对 <code>VARCHAR</code>, <code>TEXT</code> 等长字符串，只对前 N 个字符建立索引，以节省空间。</li><li>语法：<code>CREATE INDEX idx_name ON table(column(n));</code></li></ul><h2 id="7-索引的设计原则"><a href="#7-索引的设计原则" class="headerlink" title="7. 索引的设计原则"></a>7. 索引的设计原则</h2><ol><li><p><strong>针对性</strong>：对查询频次高、数据量大（&gt;100万行）的表建立索引。</p></li><li><p><strong>字段选择</strong>：</p><ul><li><code>WHERE</code> 子句中的过滤条件字段。</li><li><code>ORDER BY</code>、<code>GROUP BY</code> 涉及的字段。</li></ul></li><li><p><strong>区分度</strong>：选择区分度高（唯一性高）的列（如 UUID、手机号）。区分度低的列（如性别、状态）不适合建单列索引。</p></li><li><p><strong>联合索引优先</strong>：尽量使用联合索引，利用覆盖索引机制，减少回表。</p></li><li><p><strong>字符串优化</strong>：长字符串使用前缀索引。</p></li><li><p><strong>控制数量</strong>：索引不是越多越好，过多的索引会拖慢写性能并增加优化器负担。</p></li><li><p><strong>非空约束</strong>：尽量将字段设为 <code>NOT NULL</code>，有利于优化器确定索引效率。</p><h2 id="8-SQL-提示-SQL-Hints"><a href="#8-SQL-提示-SQL-Hints" class="headerlink" title="8. SQL 提示 (SQL Hints)"></a>8. SQL 提示 (SQL Hints)</h2><h3 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h3><ul><li><strong>定义</strong>：开发者在 SQL 语句中显式地添加指令，人为干预数据库优化器（Optimizer）对索引的选择。</li><li><strong>场景</strong>：当 MySQL 优化器生成的执行计划不是最优解（例如选错了索引，或者放弃索引走全表扫描）时使用。</li></ul><h3 id="8-2-常用语法"><a href="#8-2-常用语法" class="headerlink" title="8.2 常用语法"></a>8.2 常用语法</h3><p>SQL 提示需紧跟在表名之后。</p><h4 id="1-USE-INDEX-建议"><a href="#1-USE-INDEX-建议" class="headerlink" title="1. USE INDEX (建议)"></a>1. USE INDEX (建议)</h4><ul><li><p><strong>含义</strong>：<strong>建议</strong> MySQL 使用指定的索引之一。</p></li><li><p><strong>特点</strong>：这只是一个参考，优化器评估后如果觉得全表扫描更快，<strong>依然可能忽略</strong>该提示。</p></li><li><p><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name USE INDEX (idx_name) WHERE col = &#x27;value&#x27;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-IGNORE-INDEX-忽略"><a href="#2-IGNORE-INDEX-忽略" class="headerlink" title="2. IGNORE INDEX (忽略)"></a>2. IGNORE INDEX (忽略)</h4><ul><li><p><strong>含义</strong>：<strong>禁止</strong> MySQL 使用指定的索引。</p></li><li><p><strong>场景</strong>：</p><ul><li>用于验证某个索引是否对查询产生负面影响。</li></ul></li></ul></li></ol><ul><li><p>当你确定全表扫描比走该索引更快时（例如数据分布极不均匀）。</p></li><li><p><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name IGNORE INDEX (idx_name) WHERE col = &#x27;value&#x27;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-FORCE-INDEX-强制"><a href="#3-FORCE-INDEX-强制" class="headerlink" title="3. FORCE INDEX (强制)"></a>3. FORCE INDEX (强制)</h4><ul><li><p><strong>含义</strong>：<strong>强制</strong> MySQL 使用指定的索引。</p></li><li><p><strong>特点</strong>：比 <code>USE INDEX</code> 语气更重。如果强制的索引无法使用，MySQL 通常会选择全表扫描作为代价，极少会忽略该指令。</p></li><li><p><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name FORCE INDEX (idx_name) WHERE col = &#x27;value&#x27;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

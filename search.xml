<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[SpringBoot]分层解耦</title>
      <link href="/2026/01/24/SpringBoot-%E5%88%86%E5%B1%82%E8%A7%A3%E8%80%A6/"/>
      <url>/2026/01/24/SpringBoot-%E5%88%86%E5%B1%82%E8%A7%A3%E8%80%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="分层解耦"><a href="#分层解耦" class="headerlink" title="分层解耦"></a>分层解耦</h1><h2 id="1-三层框架"><a href="#1-三层框架" class="headerlink" title="1. 三层框架"></a>1. 三层框架</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在开发中，尽可能让每一个接口，方法，类的职责分工明确，提高可读性，扩展性；利于后期维护。</p><p>这种原则叫做<strong>单一职责原则</strong>：</p><blockquote><p>一个类或一个方法，就只做一件事情，只管一块功能。</p></blockquote><p>对于一个业务，可以拆分成三层：</p><ol><li>Controller：控制层。接收前端发送的请求，对请求进行处理，并响应数据。</li><li>Service：业务逻辑层。处理具体的业务逻辑。</li><li>Dao：数据访问层(Data Access Object)，也称为持久层。负责数据访问操作，包括数据的增、删、改、查。</li></ol><p>执行流程为：</p><ul><li>前端发起请求</li><li>Controller层接收请求</li><li>Controller层调用Service进行逻辑处理</li><li>Service去调用Dao获取所需数据</li><li>Dao层从网路上或者数据库中拿到数据并返回Service</li><li>Service对待处理数据进行逻辑处理并返回Controller</li><li>Controller把最终结果响应给前端</li><li>前端收到响应</li></ul><p>针对于这三层 一般会创建第三个包方便管理</p><ul><li><code>controller</code></li><li><code>service</code></li><li><code>dao</code></li></ul><p>对于每个包内一般采用<strong>面向接口</strong>的方式进行代码书写:</p><p>在每一层的包下书写接口类，再定义一个<code>impl</code>包用于书写该接口的实现类</p><p>实现类的命名规则为<code>接口名Impl</code>；示例如下：</p><img src="/2026/01/24/SpringBoot-%E5%88%86%E5%B1%82%E8%A7%A3%E8%80%A6/p1.png" class="" title="目录结构演示"><h2 id="2-分层解耦"><a href="#2-分层解耦" class="headerlink" title="2. 分层解耦"></a>2. 分层解耦</h2><h3 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h3><p>对于当前业务逻辑：当前端请求地址<code>/list</code>时，后端需要从项目文件下的<code>src/main/resources/user.txt</code>文件进行读取数据</p><p>文件格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1,daqiao,1234567890,大乔,22,2024-07-15 15:05:45</span><br><span class="line">2,xiaoqiao,1234567890,小乔,18,2024-07-15 15:12:09</span><br><span class="line">3,diaochan,1234567890,貂蝉,21,2024-07-15 15:07:16</span><br><span class="line">4,lvbu,1234567890,吕布,28,2024-07-16 10:05:15</span><br><span class="line">5,zhaoyun,1234567890,赵云,27,2024-07-16 11:03:28</span><br><span class="line">6,zhangfei,1234567890,张飞,31,2024-07-16 11:03:28</span><br><span class="line">7,guanyu,1234567890,关羽,34,2024-07-16 12:05:12</span><br><span class="line">8,liubei,1234567890,刘备,37,2024-07-16 15:03:28</span><br></pre></td></tr></table></figure><p>读取到数据后进行拆分并封装成已经定义好的类<code>User</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.duckling.pojo;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span> <span class="comment">//自动生成 get 和 set 方法</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span> <span class="comment">//无参构造</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span> <span class="comment">//有参构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装好后，合成一个List集合进行返回。</p><p>所以<code>Controller</code>层这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1.调用Service</span></span><br><span class="line">        List&lt;User&gt; userList = userService.findAll();</span><br><span class="line">        <span class="comment">//2.响应数据</span></span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Service</code>层中的<code>UserSerivce</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">//返回将数据转换成 User 类的数组</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Service</code>层中的<code>UserServiceImpl</code>实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; lines = userDao.findAll();</span><br><span class="line">        List&lt;User&gt; userList = lines.stream().map(line -&gt; &#123;</span><br><span class="line">            String[] parts = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> Integer.parseInt(parts[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> parts[<span class="number">1</span>];</span><br><span class="line">            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> parts[<span class="number">2</span>];</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> parts[<span class="number">3</span>];</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">age</span> <span class="operator">=</span> Integer.parseInt(parts[<span class="number">4</span>]);</span><br><span class="line">            <span class="type">LocalDateTime</span> <span class="variable">updateTime</span> <span class="operator">=</span> LocalDateTime.parse(parts[<span class="number">5</span>], DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(id, username, password, name, age, updateTime);</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Dao</code>层中的<code>UserDao</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Dao</code>层中的<code>UserDaoImpl</code>实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;user.txt&quot;</span>);</span><br><span class="line">        ArrayList&lt;String&gt; lines = IoUtil.readLines(in, StandardCharsets.UTF_8, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> lines;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现 每一层调用其它层的实现类时需要去构建这个实现类对象，比如在<code>Controller</code>层中new了<code>UserServiceImpl()</code></p><p>如果说我们需要更换实现类，比如由于业务的变更，UserServiceImpl 不能满足现有的业务需求，我们需要切换为 UserServiceImpl2 这套实现，就需要修改Contorller的代码，需要创建 UserServiceImpl2 的实现<code>new UserServiceImpl2()</code> 。</p><p>Service中调用Dao，也是类似的问题。</p><p>这种情况称之为层与层之间 <strong>耦合</strong> 了。</p><p>耦合和内聚的概念：</p><ul><li>**内聚：**软件中各个功能模块内部的功能联系。</li><li>**耦合：**衡量软件中各个层&#x2F;模块之间的依赖、关联的程度。</li></ul><p><strong>软件设计原则：高内聚低耦合。</strong></p><blockquote><p><strong>高内聚</strong>：指的是一个模块中各个元素之间的联系的紧密程度，如果各个元素(语句、程序段)之间的联系程度越高，则内聚性越高，即 “高内聚”。</p><p>**低耦合：**指的是软件中各个层、模块之间的依赖关联程序越低越好。</p></blockquote><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>我们要对现在这种情况进行<strong>解耦</strong>。</p><p>我们不再new一个实现类对象，取而代之的是</p><ul><li>提供一个容器，容器中存储一些对象(例：UserService对象)</li><li>Controller程序从容器中获取UserService类型的对象</li></ul><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><p>需要用到<strong>SpringBoot</strong>中的两个<strong>核心概念</strong>：</p><ul><li><p><strong>控制反转</strong>： Inversion Of Control，简称<strong>IOC</strong>。对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转。</p><ul><li>对象的创建权由程序员主动创建转移到容器(由容器创建、管理对象)。这个容器称为：IOC容器或Spring容器。</li></ul></li><li><p><strong>依赖注入</strong>：&#x3D; Dependency Injection，简称<strong>DI</strong>。容器为应用程序提供运行时，所依赖的资源，称之为依赖注入。</p><ul><li>程序运行时需要某个资源，此时容器就为其提供这个资源。</li><li>例：EmpController程序运行时需要EmpService对象，Spring容器就为其提供并注入EmpService对象。</li></ul></li><li><p>**bean对象：**IOC容器中创建、管理的对象，称之为：bean对象。</p></li></ul><h2 id="3-IOC-DI"><a href="#3-IOC-DI" class="headerlink" title="3. IOC &amp;&amp; DI"></a>3. IOC &amp;&amp; DI</h2><h3 id="初步演示"><a href="#初步演示" class="headerlink" title="初步演示"></a>初步演示</h3><p><strong>1). 将Service及Dao层的实现类，交给IOC容器管理</strong></p><p>在实现类加上 <code>@Component</code> 注解，就代表把当前类产生的对象交给IOC容器管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;user.txt&quot;</span>);</span><br><span class="line">        ArrayList&lt;String&gt; lines = IoUtil.readLines(in, StandardCharsets.UTF_8, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> lines;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; lines = userDao.findAll();</span><br><span class="line">        List&lt;User&gt; userList = lines.stream().map(line -&gt; &#123;</span><br><span class="line">            String[] parts = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> Integer.parseInt(parts[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> parts[<span class="number">1</span>];</span><br><span class="line">            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> parts[<span class="number">2</span>];</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> parts[<span class="number">3</span>];</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">age</span> <span class="operator">=</span> Integer.parseInt(parts[<span class="number">4</span>]);</span><br><span class="line">            <span class="type">LocalDateTime</span> <span class="variable">updateTime</span> <span class="operator">=</span> LocalDateTime.parse(parts[<span class="number">5</span>], DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(id, username, password, name, age, updateTime);</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2). 为Controller 及 Service注入运行时所依赖的对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; lines = userDao.findAll();</span><br><span class="line">        List&lt;User&gt; userList = lines.stream().map(line -&gt; &#123;</span><br><span class="line">            String[] parts = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> Integer.parseInt(parts[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> parts[<span class="number">1</span>];</span><br><span class="line">            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> parts[<span class="number">2</span>];</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> parts[<span class="number">3</span>];</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">age</span> <span class="operator">=</span> Integer.parseInt(parts[<span class="number">4</span>]);</span><br><span class="line">            <span class="type">LocalDateTime</span> <span class="variable">updateTime</span> <span class="operator">=</span> LocalDateTime.parse(parts[<span class="number">5</span>], DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(id, username, password, name, age, updateTime);</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1.调用Service</span></span><br><span class="line">        List&lt;User&gt; userList = userService.findAll();</span><br><span class="line">        <span class="comment">//2.响应数据</span></span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这只是初步对IOC和DI进行了演示，下面进行详细介绍：</p><h3 id="IOC详解"><a href="#IOC详解" class="headerlink" title="IOC详解"></a>IOC详解</h3><p>前面我们提到IOC控制反转，就是将对象的控制权交给Spring的IOC容器，由IOC容器创建及管理对象。IOC容器创建的对象称为bean对象。</p><p>Spring框架提供了四种不同的@Component的衍生注解：</p><table><thead><tr><th>注解</th><th>说明</th><th>位置</th></tr></thead><tbody><tr><td>@Component</td><td>声明bean的基础注解</td><td>不属于以下三类时，用此注解</td></tr><tr><td>@Controller</td><td>@Component的衍生注解</td><td>标注在控制层类上</td></tr><tr><td>@Service</td><td>@Component的衍生注解</td><td>标注在业务层类上</td></tr><tr><td>@Repository</td><td>@Component的衍生注解</td><td>标注在数据访问层类上（由于与mybatis整合，用的少）</td></tr></tbody></table><p>那么此时，我们就可以使用 <code>@Service</code> 注解声明Service层的bean。 使用 <code>@Repository</code> 注解声明Dao层的bean。 代码实现如下：</p><p>Service层:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; lines = userDao.findAll();</span><br><span class="line">        List&lt;User&gt; userList = lines.stream().map(line -&gt; &#123;</span><br><span class="line">            String[] parts = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> Integer.parseInt(parts[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> parts[<span class="number">1</span>];</span><br><span class="line">            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> parts[<span class="number">2</span>];</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> parts[<span class="number">3</span>];</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">age</span> <span class="operator">=</span> Integer.parseInt(parts[<span class="number">4</span>]);</span><br><span class="line">            <span class="type">LocalDateTime</span> <span class="variable">updateTime</span> <span class="operator">=</span> LocalDateTime.parse(parts[<span class="number">5</span>], DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(id, username, password, name, age, updateTime);</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dao层:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;user.txt&quot;</span>);</span><br><span class="line">        ArrayList&lt;String&gt; lines = IoUtil.readLines(in, StandardCharsets.UTF_8, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> lines;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p><strong>注意1</strong>：声明bean的时候，可以通过注解的value属性指定bean的名字，如果没有指定，默认为类名首字母小写。</p><p><strong>注意2</strong>：使用以上四个注解都可以声明bean，但是在springboot集成web开发中，声明控制器bean只能用@Controller。</p><h4 id="组件扫描"><a href="#组件扫描" class="headerlink" title="组件扫描"></a>组件扫描</h4><ul><li>前面声明bean的四大注解，要想生效，还需要被组件扫描注解 <code>@ComponentScan</code> 扫描。</li><li>该注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解 <code>@SpringBootApplication</code> 中，默认扫描的范围是启动类所在包及其子包。</li></ul><p>所以，我们在项目开发中，只需要按照如上项目结构，将项目中的所有的业务类，都放在启动类所在包的子包中，就无需考虑组件扫描问题。</p><h3 id="DI详解"><a href="#DI详解" class="headerlink" title="DI详解"></a>DI详解</h3><p>依赖注入，是指IOC容器要为应用程序去提供运行时所依赖的资源，而资源指的就是对象。</p><p>在入门程序案例中，我们使用了@Autowired这个注解，完成了依赖注入的操作，而这个Autowired翻译过来叫：自动装配。</p><p><code>@Autowired</code>注解，默认是按照<strong>类型</strong>进行自动装配的（去IOC容器中找某个类型的对象，然后完成注入操作）</p><h4 id="Autowired三种用法"><a href="#Autowired三种用法" class="headerlink" title="@Autowired三种用法"></a>@Autowired三种用法</h4><p>1). 属性注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式一: 属性注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>优点：代码简洁、方便快速开发。</li><li>缺点：隐藏了类之间的依赖关系、可能会破坏类的封装性。</li></ul><p>2). 构造函数注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式二: 构造器注入</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//如果当前类中只存在一个构造函数, @Autowired可以省略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> &#125;   </span><br></pre></td></tr></table></figure><ul><li>优点：能清晰地看到类的依赖关系、提高了代码的安全性。</li><li>缺点：代码繁琐、如果构造参数过多，可能会导致构造函数臃肿。</li><li><strong>注意：如果只有一个构造函数，@Autowired注解可以省略。（通常来说，也只有一个构造函数）</strong></li></ul><p>3). setter注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户信息Controller</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方式三: setter注入</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserService</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><ul><li>优点：保持了类的封装性，依赖关系更清晰。</li><li>缺点：需要额外编写setter方法，增加了代码量。</li></ul><p>在项目开发中，基于@Autowired进行依赖注入时，基本都是第一种和第二种方式。（官方推荐第二种方式，因为会更加规范）但是在企业项目开发中，很多的项目中，也会选择第一种方式因为更加简洁、高效（在规范性方面进行了妥协）。</p><h3 id="IOC容器中存在多个同类型bean对象的情况"><a href="#IOC容器中存在多个同类型bean对象的情况" class="headerlink" title="IOC容器中存在多个同类型bean对象的情况"></a>IOC容器中存在多个同类型bean对象的情况</h3><p>那如果在IOC容器中，存在多个相同类型的bean对象，会出现什么情况呢？</p><p>比如对于Service层中的UserService有两个实现类UserServiceImpl和UserServiceImpl2</p><p>那就会报错，因为在Spring的容器中，UserService这个类型的bean存在两个，框架不知道具体要注入哪个bean使用，所以就报错了。</p><p>Spring提供了以下几种解决方案：</p><ul><li>@Primary</li><li>@Qualifier</li><li>@Resource</li></ul><p><strong>方案一：使用@Primary注解</strong></p><p>当存在多个相同类型的Bean注入时，加上@Primary注解，来确定默认的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方案二：使用@Qualifier注解</strong></p><p>指定当前要注入的bean对象。 在@Qualifier的value属性中，指定注入的bean的名称。 @Qualifier注解不能单独使用，必须配合@Autowired使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Qualifier(&quot;userServiceImpl&quot;)</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure><p><strong>方案三：使用@Resource注解</strong></p><p>是按照bean的名称进行注入。通过name属性指定要注入的bean的名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Resource(name = &quot;userServiceImpl&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure><p>面试题：@Autowird 与 @Resource的区别</p><ul><li>@Autowired 是spring框架提供的注解，而@Resource是JDK提供的注解</li><li>@Autowired 默认是按照类型注入，而@Resource是按照名称注入</li></ul><p><em>注：@Qualifier和@Resource中填写的名称是bean的名称 当在创建bean对象的时候若没有指定名字，则默认名为该bean的类名，类名首字母小写</em></p><p><em>如：UserServiceImpl的bean名称为userServiceImpl</em></p><p>*关于bean名称相关请看<a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注1</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 后端 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP常见响应状态码</title>
      <link href="/2026/01/21/HTTP%E5%B8%B8%E8%A7%81%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>/2026/01/21/HTTP%E5%B8%B8%E8%A7%81%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>状态码分类</th><th>说明</th></tr></thead><tbody><tr><td>1xx</td><td><strong>响应中</strong>——临时状态码，表示请求已经接受，告诉客户端应该继续请求或者如果它已经完成则忽略它</td></tr><tr><td>2xx</td><td><strong>成功</strong>——表示请求已经被成功接收，处理已完成</td></tr><tr><td>3xx</td><td><strong>重定向</strong>——重定向到其它地方：它让客户端再发起一个请求以完成整个处理。</td></tr><tr><td>4xx</td><td><strong>客户端错误</strong>——处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等</td></tr><tr><td>5xx</td><td><strong>服务器端错误</strong>——处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等</td></tr></tbody></table><h2 id="二、常见的响应状态码"><a href="#二、常见的响应状态码" class="headerlink" title="二、常见的响应状态码"></a>二、常见的响应状态码</h2><table><thead><tr><th>状态码</th><th>英文描述</th><th>解释</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;200&#x3D;&#x3D;</td><td><strong><code>OK</code></strong></td><td>客户端请求成功，即<strong>处理成功</strong>，这是我们最想看到的状态码</td></tr><tr><td>302</td><td><strong><code>Found</code></strong></td><td>指示所请求的资源已移动到由<code>Location</code>响应头给定的 URL，浏览器会自动重新访问到这个页面</td></tr><tr><td>304</td><td><strong><code>Not Modified</code></strong></td><td>告诉客户端，你请求的资源至上次取得后，服务端并未更改，你直接用你本地缓存吧。隐式重定向</td></tr><tr><td>400</td><td><strong><code>Bad Request</code></strong></td><td>客户端请求有<strong>语法错误</strong>，不能被服务器所理解</td></tr><tr><td>403</td><td><strong><code>Forbidden</code></strong></td><td>服务器收到请求，但是<strong>拒绝提供服务</strong>，比如：没有权限访问相关资源</td></tr><tr><td>&#x3D;&#x3D;404&#x3D;&#x3D;</td><td><strong><code>Not Found</code></strong></td><td><strong>请求资源不存在</strong>，一般是URL输入有误，或者网站资源被删除了</td></tr><tr><td>405</td><td><strong><code>Method Not Allowed</code></strong></td><td>请求方式有误，比如应该用GET请求方式的资源，用了POST</td></tr><tr><td>428</td><td><strong><code>Precondition Required</code></strong></td><td><strong>服务器要求有条件的请求</strong>，告诉客户端要想访问该资源，必须携带特定的请求头</td></tr><tr><td>429</td><td><strong><code>Too Many Requests</code></strong></td><td>指示用户在给定时间内发送了<strong>太多请求</strong>（“限速”），配合 Retry-After(多长时间后可以请求)响应头一起使用</td></tr><tr><td>431</td><td><strong><code> Request Header Fields Too Large</code></strong></td><td><strong>请求头太大</strong>，服务器不愿意处理请求，因为它的头部字段太大。请求可以在减少请求头域的大小后重新提交。</td></tr><tr><td>&#x3D;&#x3D;500&#x3D;&#x3D;</td><td><strong><code>Internal Server Error</code></strong></td><td><strong>服务器发生不可预期的错误</strong>。服务器出异常了，赶紧看日志去吧</td></tr><tr><td>503</td><td><strong><code>Service Unavailable</code></strong></td><td><strong>服务器尚未准备好处理请求</strong>，服务器刚刚启动，还未初始化好</td></tr></tbody></table><p>状态码大全：<a href="https://cloud.tencent.com/developer/chapter/13553">https://cloud.tencent.com/developer/chapter/13553</a> </p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> HTTP协议 </category>
          
          <category> 资料 </category>
          
          <category> 学习笔记 </category>
          
          <category> HTTP </category>
          
          <category> 后端 </category>
          
          <category> HTTP协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用资料 </tag>
            
            <tag> 网络 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[算法练习26-1-19]赢彩票</title>
      <link href="/2026/01/19/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A026-1-19-%E8%B5%A2%E5%BD%A9%E7%A5%A8/"/>
      <url>/2026/01/19/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A026-1-19-%E8%B5%A2%E5%BD%A9%E7%A5%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="算法练习26-1-19-赢彩票"><a href="#算法练习26-1-19-赢彩票" class="headerlink" title="[算法练习26-1-19]赢彩票"></a>[算法练习26-1-19]赢彩票</h1><h2 id="赢球票"><a href="#赢球票" class="headerlink" title="赢球票"></a>赢球票</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>某机构举办球票大奖赛。获奖选手有机会赢得若干张球票。</p><p>主持人拿出 N 张卡片（上面写着 1⋯N 的数字），打乱顺序，排成一个圆圈。</p><p>你可以从任意一张卡片开始顺时针数数: 1,2,3 ⋯⋯</p><p>如果数到的数字刚好和卡片上的数字相同，则把该卡片收入囊中，从下一个卡片重新数数。</p><p>直到再无法收获任何卡片，游戏结束。囊中卡片数字的和就是赢得球票的张数。</p><p>比如：</p><p>卡片排列是：<code>1 2 3</code></p><p>我们从 1 号卡开始数，就把 1 号卡拿走。再从 2 号卡开始，但数的数字无法与卡片对上，很快数字越来越大，不可能再拿走卡片了。因此这次我们只赢得了 1 张球票。</p><p>还不算太坏！如果我们开始就傻傻地从 2 或 3 号卡片数起，那就一张卡片都拿不到了。</p><p>如果运气好，卡片排列是 <code>2 1 3</code>，那我们可以顺利拿到所有的卡片！</p><p>本题的目标：已知顺时针卡片序列，随便你从哪里开始数，求最多能赢多少张球票（就是收入囊中的卡片数字之和）</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><p>第一行一个整数 <em>N</em> (<em>N</em>≤100)，表示卡片数目。</p><p>第二行 <em>N</em> 个整数，表示顺时针排列的卡片。</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><p>输出一行，一个整数，表示最好情况下能赢得多少张球票。</p><h3 id="输入输出示例"><a href="#输入输出示例" class="headerlink" title="输入输出示例"></a>输入输出示例</h3><p><strong>示例</strong></p><blockquote><p>输入</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">123</span><br></pre></td></tr></table></figure><blockquote><p>输出</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="运行限制"><a href="#运行限制" class="headerlink" title="运行限制"></a>运行限制</h3><ul><li>最大运行时间：1s</li><li>最大运行内存: 256M</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>该题运用<strong>模拟</strong>和<strong>枚举</strong>进行求解。</p><p>枚举<strong>每种可能</strong> 即从第1张开始数到从第<em>N</em>张开始数 一共<em>N</em>种情况</p><p>对<strong>每种情况</strong>进行<strong>模拟</strong></p><p>第n次模拟即为从第n张牌开始数，直到数到<strong>当前序号与牌点数相同</strong>时，拿走该牌，当前模拟的总计数自加该牌点数</p><p>从下一张牌开始<strong>从头数</strong> 若遇到队尾则回到队头</p><p>直到牌全部拿走或者当前数到的序数大于最大牌的点数</p><p>所有情况模拟完毕后 选出总计数最大的那一个即为所求</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, ma, t, res[<span class="number">101</span>];<span class="comment">//n:牌的总数 ma:牌的最大点数 t:当前模拟的总计数 res[]:每次模拟计数的数组</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt; node;<span class="comment">//循环队列 记录所有牌</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt; ll;<span class="comment">//记录的是当前模拟下剩余的牌</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回从第n张牌开始数时，第一次数到的牌的迭代器</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;::<span class="function">iterator <span class="title">get</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> it = ll.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">it++;</span><br><span class="line">        <span class="comment">//若遍历到队尾 则返回为队头</span></span><br><span class="line"><span class="keyword">if</span>(it == ll.<span class="built_in">end</span>()) it = ll.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//程序枚举主代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">st</span><span class="params">(<span class="keyword">auto</span> it)</span></span>&#123;</span><br><span class="line">    <span class="comment">//递归终止条件1：当前牌堆中已无牌</span></span><br><span class="line"><span class="keyword">if</span>(ll.<span class="built_in">size</span>() &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ma; i++)&#123;</span><br><span class="line">        <span class="comment">//比较当前数的数是否与当前牌的点数一致</span></span><br><span class="line"><span class="keyword">if</span>(*it == i)&#123;</span><br><span class="line"><span class="comment">//总计数加上该牌点数</span></span><br><span class="line">            t += *it;</span><br><span class="line">            <span class="comment">//删除该牌</span></span><br><span class="line"><span class="keyword">auto</span> next = ++it;</span><br><span class="line"><span class="keyword">if</span>(next == ll.<span class="built_in">end</span>()) next = ll.<span class="built_in">begin</span>();</span><br><span class="line">ll.<span class="built_in">erase</span>(--it);</span><br><span class="line">it = next;</span><br><span class="line">            <span class="comment">//递归终止条件2：点数与当前序数一致</span></span><br><span class="line"><span class="comment">//递归 从下一张牌开始从头数</span></span><br><span class="line">            <span class="built_in">st</span>(it);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//指向下一张牌</span></span><br><span class="line">it++;</span><br><span class="line"><span class="keyword">if</span>(it == ll.<span class="built_in">end</span>()) it = ll.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//递归终止条件3：for循环结束(当前数的数已经大于最大点数)</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;         </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//输入</span></span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">        <span class="comment">//获取最大点数</span></span><br><span class="line"><span class="keyword">if</span>(a &gt; ma) ma = a;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line"></span><br><span class="line">node.<span class="built_in">push_back</span>(a);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//枚举 从第一张牌开始数到从第N张牌开始数的一共n种情况</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="comment">//还原牌堆</span></span><br><span class="line">ll = node;</span><br><span class="line">        <span class="comment">//获取当前情况第一张牌的指针</span></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">get</span>(i);</span><br><span class="line"><span class="built_in">st</span>(it);</span><br><span class="line">        <span class="comment">//记录当前情况的总计数</span></span><br><span class="line">res[i] = t;</span><br><span class="line">        <span class="comment">//还原计数器</span></span><br><span class="line">t = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序计数数组</span></span><br><span class="line"><span class="built_in">sort</span>(res<span class="number">+1</span>,res+n<span class="number">+1</span>);</span><br><span class="line">    <span class="comment">//输出最大值</span></span><br><span class="line">cout &lt;&lt; res[n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 学习笔记 </category>
          
          <category> 枚举 </category>
          
          <category> 模拟 </category>
          
          <category> 算法 </category>
          
          <category> 枚举 </category>
          
          <category> 模拟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常练习 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 枚举 </tag>
            
            <tag> 模拟 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[JavaScript]JS入门</title>
      <link href="/2026/01/19/JavaScript-JS%E5%85%A5%E9%97%A8/"/>
      <url>/2026/01/19/JavaScript-JS%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript-入门"><a href="#JavaScript-入门" class="headerlink" title="JavaScript 入门"></a>JavaScript 入门</h1><hr><h2 id="1-HTML引入方式"><a href="#1-HTML引入方式" class="headerlink" title="1.HTML引入方式"></a>1.HTML引入方式</h2><h3 id="1-1-内部脚本"><a href="#1-1-内部脚本" class="headerlink" title="1.1 内部脚本"></a>1.1 内部脚本</h3><p>将JS代码定义在HTML页面中</p><ul><li>JavaScript代码必须位于&lt;script&gt;&lt;&#x2F;script&gt;标签之间</li><li>在HTML文档中，可以在任意地方，放置任意数量的&lt;script&gt;</li><li>一般会把脚本置于&lt;body&gt;元素的底部，可改善显示速度</li></ul><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&quot;Hello JavaScript&quot;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-外部脚本"><a href="#1-2-外部脚本" class="headerlink" title="1.2 外部脚本"></a>1.2 外部脚本</h3><p>JS代码定义在外部 JS文件中，然后引入到 HTML页面中</p><ul><li>外部JS文件中，只包含JS代码，不包含&amp;ltscript&gt;标签</li><li>引入外部js的&lt;script&gt;标签，必须是双标签</li></ul><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/demo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>注意：demo.js中只有js代码，没有&lt;script&gt;标签</em></p><hr><h2 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2.基本语法"></a>2.基本语法</h2><h3 id="2-1-书写语法"><a href="#2-1-书写语法" class="headerlink" title="2.1 书写语法"></a>2.1 书写语法</h3><ul><li><p>区分大小写</p></li><li><p>每行结尾的分号可有可无</p></li><li><p>大括号表示代码块</p></li><li><p>注释：</p><ol><li><p>单行注释：<code>// 注释内容</code></p></li><li><p>多行注释：<code>/* 注释内容 */</code></p></li></ol></li></ul><h3 id="2-2-基本输出语句"><a href="#2-2-基本输出语句" class="headerlink" title="2.2 基本输出语句"></a>2.2 基本输出语句</h3><table><thead><tr><th>api</th><th>描述</th></tr></thead><tbody><tr><td>window.alert()</td><td>警告框</td></tr><tr><td>document.write()</td><td>在HTML 输出内容</td></tr><tr><td>console.log()</td><td>写入浏览器控制台</td></tr></tbody></table><h3 id="2-3-变量"><a href="#2-3-变量" class="headerlink" title="2.3 变量"></a>2.3 变量</h3><p><strong>JavaScript作为一门弱类型语言，其中的变量与常规编译型语言的变量大有不同<br></strong><br>主要通过以下三个关键字来声明变量：</p><table><thead><tr><th>关键字</th><th>解释</th></tr></thead><tbody><tr><td>var</td><td>早期ECMAScript5中用于变量声明的关键字</td></tr><tr><td>let</td><td>ECMAScript6中新增的用于变量声明的关键字，相比较var，let只在代码块内生效</td></tr><tr><td>const</td><td>声明常量的，常量一旦声明，不能修改</td></tr></tbody></table><p>注意如下几点：</p><ul><li><p>JavaScript 中变量可以存放不同类型的值</p></li><li><p>变量名需要遵循如下规则：</p><ol><li>组成字符可以是任何字母、数字、下划线（_）或美元符号（$）</li></ol><ul><li>数字不能开头</li><li>建议使用驼峰命名</li></ul></li></ul><p><strong>JS中 <code>0</code> | <code>null</code> | <code>undefined</code> | <code>&quot;&quot;</code> | <code>NaN</code> 理解成false,反之理解成true</strong></p><h3 id="2-4-数据类型"><a href="#2-4-数据类型" class="headerlink" title="2.4 数据类型"></a>2.4 数据类型</h3><p>JS中的数据类型主要分为<strong>原始类型</strong>和<strong>引用类型</strong></p><h4 id="2-4-1-原始数据类型"><a href="#2-4-1-原始数据类型" class="headerlink" title="2.4.1 原始数据类型"></a>2.4.1 原始数据类型</h4><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>number</td><td>数字（整数、小数、NaN(Not a Number)）</td></tr><tr><td>string</td><td>字符串，单双引皆可</td></tr><tr><td>boolean</td><td>布尔。true，false</td></tr><tr><td>null</td><td>对象为空</td></tr><tr><td>undefined</td><td>当声明的变量未初始化时，该变量的默认值是 undefined</td></tr></tbody></table><p>Object（对象）：最基础的引用类型，包含普通对象、数组、函数、日期、正则等，具体细分：</p><ul><li>普通对象：{ name: ‘张三’, age: 20 }</li><li>数组（Array）：[1, 2, 3]</li><li>函数（Function）：function() {}、() &#x3D;&gt; {}</li><li>日期（Date）：new Date()</li><li>正则（RegExp）：&#x2F;abc&#x2F;</li><li>其他（如 Map、Set、Error 等）</li></ul><h3 id="2-5-运算符"><a href="#2-5-运算符" class="headerlink" title="2.5 运算符"></a>2.5 运算符</h3><p>JS中的运算符大体与JAVA或CPP一致</p><table><thead><tr><th>运算规则</th><th>运算符</th></tr></thead><tbody><tr><td>算术运算符</td><td>+ , - , * , &#x2F; , % , ++ , –</td></tr><tr><td>赋值运算符</td><td>&#x3D; , +&#x3D; , -&#x3D; , *&#x3D; , &#x2F;&#x3D; , %&#x3D;</td></tr><tr><td>比较运算符</td><td>&gt; , &lt; , &gt;&#x3D; , &lt;&#x3D; , !&#x3D; , &#x3D;&#x3D; , &#x3D;&#x3D;&#x3D;   注意     &#x3D;&#x3D; 会进行类型转换，&#x3D;&#x3D;&#x3D; 不会进行类型转换</td></tr><tr><td>逻辑运算符</td><td>&amp;&amp; , || , !</td></tr><tr><td>三元运算符</td><td>条件表达式 ? true_value: false_value</td></tr></tbody></table><h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3.函数"></a>3.函数</h2><h3 id="3-1-第一种定义方式"><a href="#3-1-第一种定义方式" class="headerlink" title="3.1 第一种定义方式"></a>3.1 第一种定义方式</h3><p>第一种定义格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> 函数名(参数<span class="number">1</span>,参数<span class="number">2.</span>.)&#123;</span><br><span class="line">    要执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为JavaScript是弱数据类型的语言，所以有如下几点需要注意：</p><ul><li>形式参数不需要声明类型，并且JavaScript中不管什么类型都是let或者var去声明，加上也没有意义。</li><li>返回值也不需要声明类型，直接return即可</li></ul><p>如下示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-第二种定义方式"><a href="#3-2-第二种定义方式" class="headerlink" title="3.2 第二种定义方式"></a>3.2 第二种定义方式</h3><p>第二种可以通过var去定义函数的名字，具体格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> functionName = <span class="keyword">function</span> (<span class="params">参数<span class="number">1</span>,参数<span class="number">2.</span>.</span>)&#123;   </span><br><span class="line"><span class="comment">//要执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-JavaScript对象"><a href="#4-JavaScript对象" class="headerlink" title="4.JavaScript对象"></a>4.JavaScript对象</h2><p><strong>JavaScript对象可以大体分页3大类</strong></p><h3 id="4-1基本对象"><a href="#4-1基本对象" class="headerlink" title="4.1基本对象"></a>4.1基本对象</h3><h4 id="4-1-1-Array对象"><a href="#4-1-1-Array对象" class="headerlink" title="4.1.1 Array对象"></a>4.1.1 Array对象</h4><h5 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h5><p>Array对象时用来定义数组的。常用语法格式有如下2种：</p><p>方式1：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = <span class="keyword">new</span> <span class="title class_">Array</span>(元素列表); </span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>); <span class="comment">//1,2,3,4 是存储在数组中的数据（元素）</span></span><br></pre></td></tr></table></figure><p>方式2：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = [ 元素列表 ]; </span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]; <span class="comment">//1,2,3,4 是存储在数组中的数据（元素）</span></span><br></pre></td></tr></table></figure><p>数组定义好了，那么我们该如何获取数组中的值呢？和java中一样，需要通过索引来获取数组中的值。语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[索引] = 值;</span><br></pre></td></tr></table></figure><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p><code>JavaScript</code>数组的长度是可以变化的，而且数组中可以存储任意数据类型的值</p><h5 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h5><p>Array作为一个对象，那么对象是有属性和方法的，所以接下来我们介绍一下Array对象的属性和方法</p><p>官方文档中提供了Array的很多属性和方法，但是我们只学习常用的属性和方法，如下图所示：</p><p>属性：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">length</td><td align="left">设置或返回数组中元素的数量。</td></tr></tbody></table><p>方法：</p><table><thead><tr><th align="left">方法方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">forEach()</td><td align="left">遍历数组中的每个有值得元素，并调用一次传入的函数</td></tr><tr><td align="left">push()</td><td align="left">将新元素添加到数组的末尾，并返回新的长度</td></tr><tr><td align="left">splice()</td><td align="left">从数组中删除元素</td></tr></tbody></table><ul><li><p>length属性：</p><p>length属性可以用来获取数组的长度，所以我们可以借助这个属性，来遍历数组中的元素，添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">arr[<span class="number">10</span>] = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>forEach()函数</p><p>首先我们学习forEach()方法，顾名思义，这是用来遍历的，那么遍历做什么事呢？所以这个方法的参数，需要传递一个函数，而且这个函数接受一个参数，就是遍历时数组的值。修改之前的遍历代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//e是形参，接受的是数组遍历时的值</span></span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在ES6中，引入箭头函数的写法，语法类似java中lambda表达式，修改上述代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><p><em>没有元素的内容是不会输出的，因为forEach只会遍历有值的元素</em></p></li></ul></li><li><p>push()函数</p><p>push()函数是用于向数组的末尾添加元素的，其中函数的参数就是需要添加的元素，编写如下代码：向数组的末尾添加3个元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//push: 添加元素到数组末尾</span></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure></li><li><p>splice()函数</p><p>splice()函数用来数组中的元素，函数中填入2个参数。</p><p>参数1：表示从哪个索引位置删除</p><p>参数2：表示删除元素的个数</p><p>如下代码表示：从索引2的位置开始删，删除2个元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//splice: 删除元素</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-1-2-String对象"><a href="#4-1-2-String对象" class="headerlink" title="4.1.2 String对象"></a>4.1.2 String对象</h4><h5 id="语法格式-1"><a href="#语法格式-1" class="headerlink" title="语法格式"></a>语法格式</h5><p>String对象的创建方式有2种：</p><p>方式1：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;…&quot;</span>) ; <span class="comment">//方式一</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello String&quot;</span>);</span><br></pre></td></tr></table></figure><p>方式2：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = <span class="string">&quot;…&quot;</span> ; <span class="comment">//方式二</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Hello String&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="性和方法"><a href="#性和方法" class="headerlink" title="性和方法"></a>性和方法</h5><p>String对象也提供了一些常用的属性和方法，如下表格所示：</p><p>属性：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>length</td><td>字符串的长度。</td></tr></tbody></table><p>方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>charAt()</td><td>返回在指定位置的字符。</td></tr><tr><td>indexOf()</td><td>检索字符串。</td></tr><tr><td>trim()</td><td>去除字符串两边的空格</td></tr><tr><td>substring()</td><td>提取字符串中两个指定的索引号之间的字符。</td></tr></tbody></table><ul><li><p>length属性：</p><p>length属性可以用于返回字符串的长度，添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//length</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="property">length</span>);</span><br></pre></td></tr></table></figure></li><li><p>charAt()函数：</p><p>charAt()函数用于返回在指定索引位置的字符，函数的参数就是索引。添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">charAt</span>(<span class="number">4</span>));</span><br></pre></td></tr></table></figure></li><li><p>indexOf()函数</p><p>indexOf()函数用于检索指定内容在字符串中的索引位置的，返回值是索引，参数是指定的内容。添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">indexOf</span>(<span class="string">&quot;lo&quot;</span>));</span><br></pre></td></tr></table></figure></li><li><p>trim()函数</p><p>trim()函数用于去除字符串两边的空格的。添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = str.<span class="title function_">trim</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">length</span>);</span><br></pre></td></tr></table></figure></li><li><p>substring()函数</p><p>substring()函数用于截取字符串的，函数有2个参数。</p><p>参数1：表示从那个索引位置开始截取。包含</p><p>参数2：表示到那个索引位置结束。不包含</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">substring</span>(<span class="number">0</span>,<span class="number">5</span>));</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-1-3-JSON对象"><a href="#4-1-3-JSON对象" class="headerlink" title="4.1.3 JSON对象"></a>4.1.3 JSON对象</h4><h5 id="自定义对象"><a href="#自定义对象" class="headerlink" title="自定义对象"></a>自定义对象</h5><p>在 JavaScript 中自定义对象特别简单，其语法格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 对象名 = &#123;</span><br><span class="line">    属性名<span class="number">1</span>: 属性值<span class="number">1</span>, </span><br><span class="line">    属性名<span class="number">2</span>: 属性值<span class="number">2</span>,</span><br><span class="line">    属性名<span class="number">3</span>: 属性值<span class="number">3</span>,</span><br><span class="line">    函数名称: <span class="keyword">function</span>(<span class="params">形参列表</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以通过如下语法调用属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.属性名</span><br></pre></td></tr></table></figure><p>通过如下语法调用函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.函数名()</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//自定义对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> user = &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">age</span>: <span class="number">18</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">gender</span>: <span class="string">&quot;male&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">eat</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">             <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;正在吃饭&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">         &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">name</span>);</span></span><br><span class="line"><span class="language-javascript">    user.<span class="title function_">eat</span>();</span></span><br><span class="line"><span class="language-javascript">&lt;script&gt;</span></span><br></pre></td></tr></table></figure><p>其中上述函数定义的语法可以简化成如下格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&quot;male&quot;</span>,</span><br><span class="line">    <span class="title function_">eat</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;正在吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="json对象"><a href="#json对象" class="headerlink" title="json对象"></a>json对象</h5><p>JSON对象：<strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation，JavaScript对象标记法。是通过JavaScript标记法书写的文本。其格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;key&quot;</span>:value,</span><br><span class="line">    <span class="string">&quot;key&quot;</span>:value,</span><br><span class="line">    <span class="string">&quot;key&quot;</span>:value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<strong>key必须使用引号并且是双引号标记，value可以是任意数据类型。</strong></p><p><code>JSON</code>经常用来作为前后台交互的数据载体</p><h6 id="json字符串和json对象的转换"><a href="#json字符串和json对象的转换" class="headerlink" title="json字符串和json对象的转换"></a>json字符串和json对象的转换</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonstr);</span><br><span class="line"><span class="title function_">alert</span>(obj.<span class="property">name</span>); </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj)); </span><br></pre></td></tr></table></figure><h3 id="4-2-BOM对象"><a href="#4-2-BOM对象" class="headerlink" title="4.2 BOM对象"></a>4.2 BOM对象</h3><p>BOM中提供了如下5个对象：</p><table><thead><tr><th align="left">对象名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Window</td><td align="left">浏览器窗口对象</td></tr><tr><td align="left">Navigator</td><td align="left">浏览器对象</td></tr><tr><td align="left">Screen</td><td align="left">屏幕对象</td></tr><tr><td align="left">History</td><td align="left">历史记录对象</td></tr><tr><td align="left">Location</td><td align="left">地址栏对象</td></tr></tbody></table><h4 id="4-2-1-Window对象"><a href="#4-2-1-Window对象" class="headerlink" title="4.2.1 Window对象"></a>4.2.1 Window对象</h4><p>window对象指的是浏览器窗口对象，是JavaScript的全部对象，所以对于window对象，我们可以直接使用，并且对于window对象的方法和属性，我们可以省略window.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.alert(&#x27;hello&#x27;);</span><br></pre></td></tr></table></figure><p>其可以省略window.  所以可以简写成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(&#x27;hello&#x27;)</span><br></pre></td></tr></table></figure><p>所以对于window对象的属性和方法，我们都是采用简写的方式。window提供了很多属性和方法，下表列出了常用属性和方法</p><p>window对象提供了获取其他BOM对象的属性：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>history</td><td>用于获取history对象</td></tr><tr><td>location</td><td>用于获取location对象</td></tr><tr><td>Navigator</td><td>用于获取Navigator对象</td></tr><tr><td>Screen</td><td>用于获取Screen对象</td></tr></tbody></table><p>也就是说我们要使用location对象，只需要通过代码<code>window.location</code>或者简写<code>location</code>即可使用</p><p>window也提供了一些常用的函数，如下表格所示：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>alert()</td><td>显示带有一段消息和一个确认按钮的警告框。</td></tr><tr><td>comfirm()</td><td>显示带有一段消息以及确认按钮和取消按钮的对话框。</td></tr><tr><td>setInterval()</td><td>按照指定的周期（以毫秒计）来调用函数或计算表达式。</td></tr><tr><td>setTimeout()</td><td>在指定的毫秒数后调用函数或计算表达式。</td></tr></tbody></table><ul><li><p>alert()函数：弹出警告框，函数的内容就是警告框的内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//window对象是全局对象，window对象的属性和方法在调用时可以省略window.</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="string">&quot;Hello BOM&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&quot;Hello BOM Window&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>confirm()函数：弹出确认框，并且提供用户2个按钮，分别是确认和取消。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">confirm</span>(<span class="string">&quot;您确认删除该记录吗?&quot;</span>);</span><br></pre></td></tr></table></figure><p>该函数有一个返回值，当用户点击确认时，返回true，点击取消时，返回false。我们根据返回值来决定是否执行后续操作。修改代码如下：再次运行，可以查看返回值true或者false</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flag = <span class="title function_">confirm</span>(<span class="string">&quot;您确认删除该记录吗?&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(flag);</span><br></pre></td></tr></table></figure></li><li><p>setInterval(fn,毫秒值)：定时器，用于周期性的执行某个功能，并且是<strong>循环执行</strong>。该函数需要传递2个参数：</p><p>fn:函数，需要周期性执行的功能代码</p><p>毫秒值：间隔时间</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定时器 - setInterval -- 周期性的执行某一个函数</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">     i++;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;定时器执行了&quot;</span>+i+<span class="string">&quot;次&quot;</span>);</span><br><span class="line">&#125;,<span class="number">2000</span>);</span><br></pre></td></tr></table></figure></li><li><p>setTimeout(fn,毫秒值) ：定时器，只会在一段时间后<strong>执行一次功能</strong>。参数和上述setInterval一致</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定时器 - setTimeout -- 延迟指定时间执行一次 </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;JS&quot;</span>);</span><br><span class="line">&#125;,<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>浏览器打开，3s后弹框，关闭弹框，发现再也不会弹框了。</p></li></ul><h4 id="4-2-2-Location对象"><a href="#4-2-2-Location对象" class="headerlink" title="4.2.2 Location对象"></a>4.2.2 Location对象</h4><p>location是指代浏览器的地址栏对象，对于这个对象，我们常用的是href属性，用于获取或者设置浏览器的地址信息</p><h3 id="4-3-DOM对象"><a href="#4-3-DOM对象" class="headerlink" title="4.3 DOM对象"></a>4.3 DOM对象</h3><h4 id="4-3-1-DOM介绍"><a href="#4-3-1-DOM介绍" class="headerlink" title="4.3.1 DOM介绍"></a>4.3.1 DOM介绍</h4><p>DOM：Document Object Model 文档对象模型。也就是 JavaScript 将 HTML 文档的各个组成部分封装为对象。</p><ul><li>Document：整个文档对象</li><li>Element：元素对象</li><li>Attribute：属性对象</li><li>Text：文本对象</li><li>Comment：注释对象</li></ul><p>主要作用如下：</p><ul><li>改变 HTML 元素的内容</li><li>改变 HTML 元素的样式（CSS）</li><li>对 HTML DOM 事件作出反应</li><li>添加和删除 HTML 元素</li></ul><h4 id="4-3-2-获取DOM对象"><a href="#4-3-2-获取DOM对象" class="headerlink" title="4.3.2 获取DOM对象"></a>4.3.2 获取DOM对象</h4><p>HTML中的Element对象可以通过Document对象获取，而Document对象是通过window对象获取的。document对象提供的用于获取Element元素对象的api如下表所示：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>document.getElementById()</td><td>根据id属性值获取，返回单个Element对象</td></tr><tr><td>document.getElementsByTagName()</td><td>根据标签名称获取，返回Element对象数组</td></tr><tr><td>document.getElementsByName()</td><td>根据name属性值获取，返回Element对象数组</td></tr><tr><td>document.getElementsByClassName()</td><td>根据class属性值获取，返回Element对象数组</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
          <category> 学习笔记 </category>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MySQL]锁</title>
      <link href="/2026/01/17/MySQL-%E9%94%81/"/>
      <url>/2026/01/17/MySQL-%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-锁机制"><a href="#MySQL-锁机制" class="headerlink" title="MySQL 锁机制"></a>MySQL 锁机制</h1><blockquote><p><strong>核心摘要</strong>：MySQL 的锁机制主要用于管理共享资源的并发访问。根据加锁粒度，主要分为 <strong>全局锁</strong>、<strong>表级锁</strong> 和 <strong>行级锁</strong>。</p></blockquote><h2 id="一、-全局锁-Global-Locks"><a href="#一、-全局锁-Global-Locks" class="headerlink" title="一、 全局锁 (Global Locks)"></a>一、 全局锁 (Global Locks)</h2><p>全局锁就是对整个数据库实例加锁。</p><h3 id="1-核心作用"><a href="#1-核心作用" class="headerlink" title="1. 核心作用"></a>1. 核心作用</h3><p>让整个库处于 <strong>只读状态 (Read-Only)</strong>。</p><h3 id="2-语法演示"><a href="#2-语法演示" class="headerlink" title="2. 语法演示"></a>2. 语法演示</h3><ul><li><p><strong>加锁命令</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH TABLES WITH READ LOCK;</span><br></pre></td></tr></table></figure></li><li><p><strong>解锁命令</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure><p><em>(注意：如果客户端连接断开，锁也会自动释放)</em></p></li></ul><h3 id="3-锁生效后的行为代码演示"><a href="#3-锁生效后的行为代码演示" class="headerlink" title="3. 锁生效后的行为代码演示"></a>3. 锁生效后的行为代码演示</h3><p>假设我们执行了上面的加锁命令，此时不同类型的 SQL 语句表现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 1. 查询语句 (DQL) -&gt; ✅ 成功</span><br><span class="line">SELECT * FROM user_info;</span><br><span class="line"></span><br><span class="line">-- 2. 数据更新语句 (DML) -&gt; ❌ 阻塞 (Blocked)</span><br><span class="line">INSERT INTO user_info (name) VALUES (&#x27;Alice&#x27;);</span><br><span class="line">-- 状态：一直等待，直到全局锁释放或超时</span><br><span class="line"></span><br><span class="line">-- 3. 表结构修改语句 (DDL) -&gt; ❌ 阻塞 (Blocked)</span><br><span class="line">ALTER TABLE user_info ADD COLUMN age INT;</span><br></pre></td></tr></table></figure><h2 id="二、-表级锁-Table-level-Locks"><a href="#二、-表级锁-Table-level-Locks" class="headerlink" title="二、 表级锁 (Table-level Locks)"></a>二、 表级锁 (Table-level Locks)</h2><p>MySQL 的表级锁主要包含两种：<strong>显式表锁</strong> 和 <strong>元数据锁 (MDL)</strong>。</p><h3 id="1-显式表锁-Explicit-Table-Locks"><a href="#1-显式表锁-Explicit-Table-Locks" class="headerlink" title="1. 显式表锁 (Explicit Table Locks)"></a>1. 显式表锁 (Explicit Table Locks)</h3><p>显式表锁分为 <strong>读锁 (Read Lock)</strong> 和 <strong>写锁 (Write Lock)</strong>。</p><h4 id="1-表读锁-Read-Lock"><a href="#1-表读锁-Read-Lock" class="headerlink" title="(1) 表读锁 (Read Lock)"></a>(1) 表读锁 (Read Lock)</h4><ul><li><strong>语法</strong>：<code>LOCK TABLES 表名 READ;</code></li><li><strong>特性</strong>：<strong>共享锁</strong>。当前线程和其他线程都<strong>只能读，不能写</strong>。</li></ul><table><thead><tr><th>动作</th><th>当前持有锁的线程 (Session A)</th><th>其他线程 (Session B)</th></tr></thead><tbody><tr><td><strong>读 (SELECT)</strong></td><td>✅ 可执行</td><td>✅ 可执行</td></tr><tr><td><strong>写 (UPDATE&#x2F;INSERT)</strong></td><td>❌ <strong>报错</strong> (Can’t update table ‘x’ while ‘x’ is locked)</td><td>⏸️ <strong>阻塞等待</strong> (Waiting for table metadata lock)</td></tr></tbody></table><h4 id="2-表写锁-Write-Lock"><a href="#2-表写锁-Write-Lock" class="headerlink" title="(2) 表写锁 (Write Lock)"></a>(2) 表写锁 (Write Lock)</h4><ul><li><strong>语法</strong>：<code>LOCK TABLES 表名 WRITE;</code></li><li><strong>特性</strong>：<strong>排他锁</strong>。当前线程可以读写，<strong>其他线程既不能读也不能写</strong>。</li></ul><table><thead><tr><th>动作</th><th>当前持有锁的线程 (Session A)</th><th>其他线程 (Session B)</th></tr></thead><tbody><tr><td><strong>读 (SELECT)</strong></td><td>✅ 可执行</td><td>⏸️ <strong>阻塞等待</strong></td></tr><tr><td><strong>写 (UPDATE&#x2F;INSERT)</strong></td><td>✅ 可执行</td><td>⏸️ <strong>阻塞等待</strong></td></tr></tbody></table><h3 id="2-元数据锁-Metadata-Lock-MDL"><a href="#2-元数据锁-Metadata-Lock-MDL" class="headerlink" title="2. 元数据锁 (Metadata Lock - MDL)"></a>2. 元数据锁 (Metadata Lock - MDL)</h3><ul><li><strong>触发方式</strong>：系统自动添加，无需显式 SQL。</li><li><strong>目的</strong>：维护表结构一致性。</li></ul><h4 id="MDL-锁类型详解"><a href="#MDL-锁类型详解" class="headerlink" title="MDL 锁类型详解"></a>MDL 锁类型详解</h4><table><thead><tr><th>类型</th><th>触发场景</th><th>兼容性</th></tr></thead><tbody><tr><td><strong>MDL 读锁</strong></td><td>对表进行增删改查 (SELECT, INSERT, UPDATE…)</td><td>与其他 <strong>MDL 读锁</strong> 兼容与 <strong>MDL 写锁</strong> 互斥</td></tr><tr><td><strong>MDL 写锁</strong></td><td>对表结构进行修改 (ALTER TABLE, DROP TABLE…)</td><td>与 <strong>所有锁</strong> (读&#x2F;写) 都互斥</td></tr></tbody></table><p><strong>演示示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- Session A (正在查询，未提交，持有 MDL 读锁)</span><br><span class="line">BEGIN;</span><br><span class="line">SELECT * FROM student; </span><br><span class="line"></span><br><span class="line">-- Session B (尝试修改表结构，需要申请 MDL 写锁)</span><br><span class="line">ALTER TABLE student ADD COLUMN score INT;</span><br><span class="line">-- 结果：⏸️ 阻塞 (Blocked)，因为 MDL 读写互斥</span><br><span class="line"></span><br><span class="line">-- Session C (尝试查询)</span><br><span class="line">SELECT * FROM student;</span><br><span class="line">-- 结果：⏸️ 阻塞！(通常会被 Session B 的写锁请求阻塞在队列中)</span><br></pre></td></tr></table></figure><h2 id="三、-行级锁-Row-level-Locks"><a href="#三、-行级锁-Row-level-Locks" class="headerlink" title="三、 行级锁 (Row-level Locks)"></a>三、 行级锁 (Row-level Locks)</h2><p><strong>前提</strong>：行锁由存储引擎实现，<strong>InnoDB 支持，MyISAM 不支持</strong>。</p><p>InnoDB 的行锁主要分为 <strong>共享锁 (S锁)</strong> 和 <strong>排他锁 (X锁)</strong>。</p><h3 id="1-共享锁-Shared-Lock-S锁"><a href="#1-共享锁-Shared-Lock-S锁" class="headerlink" title="1. 共享锁 (Shared Lock &#x2F; S锁)"></a>1. 共享锁 (Shared Lock &#x2F; S锁)</h3><ul><li><p><strong>概念</strong>：又称读锁。允许一个事务去读一行，阻止其他事务获得该行的排他锁。</p></li><li><p><strong>适用场景</strong>：确保读取的数据在处理期间不被他人修改。</p></li><li><p><strong>SQL 语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 手动添加 S 锁</span><br><span class="line">SELECT * FROM student WHERE id = 1 LOCK IN SHARE MODE;</span><br><span class="line">-- 或者 MySQL 8.0+ 写法</span><br><span class="line">SELECT * FROM student WHERE id = 1 FOR SHARE;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-排他锁-Exclusive-Lock-X锁"><a href="#2-排他锁-Exclusive-Lock-X锁" class="headerlink" title="2. 排他锁 (Exclusive Lock &#x2F; X锁)"></a>2. 排他锁 (Exclusive Lock &#x2F; X锁)</h3><ul><li><p><strong>概念</strong>：又称写锁。允许获取排他锁的事务更新数据，阻止其他事务获取该行的 S 锁或 X 锁。</p></li><li><p><strong>SQL 语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 1. 自动添加：对于 UPDATE, DELETE, INSERT 语句，InnoDB 会自动给涉及的数据行加 X 锁</span><br><span class="line">UPDATE student SET name = &#x27;Tom&#x27; WHERE id = 1;</span><br><span class="line"></span><br><span class="line">-- 2. 手动添加：查询时顺便加 X 锁</span><br><span class="line">SELECT * FROM student WHERE id = 1 FOR UPDATE;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-行锁的兼容性矩阵"><a href="#3-行锁的兼容性矩阵" class="headerlink" title="3. 行锁的兼容性矩阵"></a>3. 行锁的兼容性矩阵</h3><table><thead><tr><th>当前锁 \ 请求锁</th><th>S 锁 (共享&#x2F;读)</th><th>X 锁 (排他&#x2F;写)</th></tr></thead><tbody><tr><td><strong>已持有 S 锁</strong></td><td>✅ 兼容 (大家都能读)</td><td>❌ 冲突 (别人不能改)</td></tr><tr><td><strong>已持有 X 锁</strong></td><td>❌ 冲突 (别人不能读)</td><td>❌ 冲突 (别人不能改)</td></tr></tbody></table><h2 id="四、-意向锁-Intention-Locks"><a href="#四、-意向锁-Intention-Locks" class="headerlink" title="四、 意向锁 (Intention Locks)"></a>四、 意向锁 (Intention Locks)</h2><p>这是一种<strong>表级锁</strong>，主要为了解决行锁和表锁的冲突问题。</p><h3 id="1-场景问题"><a href="#1-场景问题" class="headerlink" title="1. 场景问题"></a>1. 场景问题</h3><p>假设事务 A 锁住了表中的<strong>某一行</strong>（加了行级 X 锁）。 此时事务 B 想要申请<strong>整个表的写锁</strong> (<code>LOCK TABLES ... WRITE</code>)。 如果没有意向锁，事务 B 需要遍历表中的每一行，查看是否被锁住。这效率极低。</p><h3 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h3><ul><li><strong>意向共享锁 (IS)</strong>：事务打算给数据行加行级 S 锁前，必须先取得该表的 IS 锁。</li><li><strong>意向排他锁 (IX)</strong>：事务打算给数据行加行级 X 锁前，必须先取得该表的 IX 锁。</li></ul><h3 id="3-效果"><a href="#3-效果" class="headerlink" title="3. 效果"></a>3. 效果</h3><p>事务 B 申请表锁时，只需要看表上是否有 IX 锁。如果有，说明表里有人正在改数据，直接阻塞等待，不需要遍历。</p><h2 id="五、-锁的算法"><a href="#五、-锁的算法" class="headerlink" title="五、 锁的算法"></a>五、 锁的算法</h2><p>InnoDB 的行锁实际上是锁在<strong>索引</strong>上的。</p><ol><li><strong>Record Lock</strong>：单个行记录上的锁。<ul><li><code>SELECT * FROM t WHERE id = 1 FOR UPDATE;</code> (id 是主键)</li></ul></li><li><strong>Gap Lock (间隙锁)</strong>：锁定一个范围，但不包含记录本身。<ul><li>防止幻读 (Phantom Read)。</li><li>例如锁住 (5, 10) 之间的空隙，防止插入 id&#x3D;7 的记录。</li></ul></li><li><strong>Next-Key Lock</strong>：Record Lock + Gap Lock。<ul><li>锁定一个范围，并且锁定记录本身。</li><li>InnoDB 默认加锁单位。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
          <category> 学习笔记 </category>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MySQL]视图&amp;触发器</title>
      <link href="/2026/01/16/MySQL-%E8%A7%86%E5%9B%BE-%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
      <url>/2026/01/16/MySQL-%E8%A7%86%E5%9B%BE-%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="视图-Views"><a href="#视图-Views" class="headerlink" title="视图 (Views)"></a>视图 (Views)</h1><h2 id="1-核心定义"><a href="#1-核心定义" class="headerlink" title="1. 核心定义"></a>1. 核心定义</h2><p>视图是一个<strong>虚拟表</strong>，其内容由查询定义。</p><ul><li>同真实的表一样，视图包含一系列带有名称的列和行数据。</li><li><strong>关键点</strong>：视图并不在数据库中以存储的数据值集形式存在（不占物理空间，只存定义）。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。</li></ul><h2 id="2-语法操作"><a href="#2-语法操作" class="headerlink" title="2. 语法操作"></a>2. 语法操作</h2><h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE [OR REPLACE] [ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]</span><br><span class="line">VIEW view_name [(column_list)]</span><br><span class="line">AS select_statement</span><br><span class="line">[WITH [CASCADED | LOCAL] CHECK OPTION];</span><br></pre></td></tr></table></figure><ul><li><strong>ALGORITHM 参数详解</strong>:<ul><li><code>MERGE</code>: 将视图的SQL语句与外部查询合并（效率高，优先推荐）。</li><li><code>TEMPTABLE</code>: 将视图结果存入临时表，再执行外部查询（无法更新数据）。</li><li><code>UNDEFINED</code>: 让MySQL自动选择（默认）。</li></ul></li><li><strong>WITH CHECK OPTION</strong>: 更新视图数据时，强行保证数据仍符合视图定义的 WHERE 条件，否则报错。</li></ul><h3 id="查看与修改"><a href="#查看与修改" class="headerlink" title="查看与修改"></a>查看与修改</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 查看结构</span><br><span class="line">DESC view_name;</span><br><span class="line">SHOW CREATE VIEW view_name;</span><br><span class="line"></span><br><span class="line">-- 修改定义</span><br><span class="line">ALTER VIEW view_name AS select_statement;</span><br><span class="line"></span><br><span class="line">-- 删除视图</span><br><span class="line">DROP VIEW [IF EXISTS] view_name;</span><br></pre></td></tr></table></figure><h2 id="3-视图的可更新性"><a href="#3-视图的可更新性" class="headerlink" title="3. 视图的可更新性"></a>3. 视图的可更新性</h2><p>并非所有视图都能执行 <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>。如果视图定义包含以下任意一项，则该视图<strong>不可更新</strong>：</p><ol><li><strong>聚合函数</strong> (<code>SUM()</code>, <code>MIN()</code>, <code>MAX()</code>, <code>COUNT()</code> 等)。</li><li><strong>DISTINCT</strong> 关键字。</li><li><strong>GROUP BY</strong> 子句。</li><li><strong>HAVING</strong> 子句。</li><li><strong>UNION</strong> 或 <strong>UNION ALL</strong>。</li><li>FROM 子句中包含<strong>不可更新的视图</strong>。</li><li>SELECT 子句中的子查询。</li><li>仅引用了字面值（Literal value）。</li><li>ALGORITHM 指定为 <code>TEMPTABLE</code>。</li></ol><h1 id="触发器-Triggers"><a href="#触发器-Triggers" class="headerlink" title="触发器 (Triggers)"></a>触发器 (Triggers)</h1><h2 id="1-核心定义-1"><a href="#1-核心定义-1" class="headerlink" title="1. 核心定义"></a>1. 核心定义</h2><p>触发器是与表有关的数据库对象，在满足定义条件（Insert&#x2F;Update&#x2F;Delete）时触发，并自动执行触发器中定义的语句集合。</p><h2 id="2-六种触发场景"><a href="#2-六种触发场景" class="headerlink" title="2. 六种触发场景"></a>2. 六种触发场景</h2><p>MySQL 仅支持<strong>行级触发器</strong> (<code>FOR EACH ROW</code>)，不支持语句级触发器。</p><table><thead><tr><th>动作</th><th>时机</th><th>组合方式</th></tr></thead><tbody><tr><td><strong>INSERT</strong></td><td>BEFORE &#x2F; AFTER</td><td><code>BEFORE INSERT</code>, <code>AFTER INSERT</code></td></tr><tr><td><strong>UPDATE</strong></td><td>BEFORE &#x2F; AFTER</td><td><code>BEFORE UPDATE</code>, <code>AFTER UPDATE</code></td></tr><tr><td><strong>DELETE</strong></td><td>BEFORE &#x2F; AFTER</td><td><code>BEFORE DELETE</code>, <code>AFTER DELETE</code></td></tr></tbody></table><h2 id="3-NEW-与-OLD-关键字"><a href="#3-NEW-与-OLD-关键字" class="headerlink" title="3. NEW 与 OLD 关键字"></a>3. NEW 与 OLD 关键字</h2><p>在触发器主体中，必须使用 <code>OLD</code> 和 <code>NEW</code> 关键字来访问行数据：</p><table><thead><tr><th>操作</th><th>NEW (新值)</th><th>OLD (旧值)</th></tr></thead><tbody><tr><td><strong>INSERT</strong></td><td><strong>可用</strong> (即将&#x2F;已插入的值)</td><td>不可用</td></tr><tr><td><strong>UPDATE</strong></td><td><strong>可用</strong> (更新后的值)</td><td><strong>可用</strong> (更新前的值)</td></tr><tr><td><strong>DELETE</strong></td><td>不可用</td><td><strong>可用</strong> (即将&#x2F;已删除的值)</td></tr></tbody></table><ul><li><code>NEW.column_name</code>: 拥有<strong>读写</strong>权限（在 <code>BEFORE</code> 触发器中可修改 <code>NEW</code> 值以强行改变入库数据）。</li><li><code>OLD.column_name</code>: 仅有<strong>只读</strong>权限。</li></ul><h2 id="4-语法操作"><a href="#4-语法操作" class="headerlink" title="4. 语法操作"></a>4. 语法操作</h2><h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line">CREATE TRIGGER trigger_name</span><br><span class="line">&#123;BEFORE | AFTER&#125; &#123;INSERT | UPDATE | DELETE&#125;</span><br><span class="line">ON table_name</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">    -- 触发器逻辑</span><br><span class="line">    -- 示例：阻断非法操作</span><br><span class="line">    -- IF NEW.amount &lt; 0 THEN </span><br><span class="line">    --    SIGNAL SQLSTATE &#x27;45000&#x27; SET MESSAGE_TEXT = &#x27;Amount cannot be negative&#x27;; </span><br><span class="line">    -- END IF;</span><br><span class="line">END$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h3 id="查看与删除"><a href="#查看与删除" class="headerlink" title="查看与删除"></a>查看与删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查看</span><br><span class="line">SHOW TRIGGERS;</span><br><span class="line">SHOW CREATE TRIGGER trigger_name;</span><br><span class="line"></span><br><span class="line">-- 删除</span><br><span class="line">DROP TRIGGER [IF EXISTS] [schema_name.]trigger_name;</span><br></pre></td></tr></table></figure><h2 id="5-核心限制与注意事项"><a href="#5-核心限制与注意事项" class="headerlink" title="5. 核心限制与注意事项"></a>5. 核心限制与注意事项</h2><ol><li><strong>事务一致性</strong>: 触发器与触发它的语句处于<strong>同一个事务</strong>中。<ul><li>若 <code>BEFORE</code> 触发器失败，SQL语句不执行。</li><li>若 SQL 语句失败，<code>AFTER</code> 触发器不执行。</li><li>若 <code>AFTER</code> 触发器失败，整个事务回滚。</li></ul></li><li><strong>禁止语句</strong>: 触发器内部<strong>不能</strong>包含显式的事务控制语句（如 <code>START TRANSACTION</code>, <code>COMMIT</code>, <code>ROLLBACK</code>）。</li><li><strong>返回值</strong>: 触发器不能返回结果集（Result Set），只能通过 <code>SIGNAL SQLSTATE</code> 抛出异常中断操作。</li><li><strong>递归</strong>: 默认情况下，MySQL 不禁止触发器引发循环调用（需注意逻辑死循环）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
          <category> 学习笔记 </category>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MySQL]优化</title>
      <link href="/2026/01/15/MySQL-SQL%E4%BC%98%E5%8C%96/"/>
      <url>/2026/01/15/MySQL-SQL%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="1-插入数据优化-Insert-Optimization"><a href="#1-插入数据优化-Insert-Optimization" class="headerlink" title="1. 插入数据优化 (Insert Optimization)"></a>1. 插入数据优化 (Insert Optimization)</h3><p><strong>核心目标：</strong> 减少磁盘I&#x2F;O交互次数，降低日志刷新频率。</p><ul><li><p>批量插入 (Batch Insert):</p><p>不要使用多条 INSERT INTO 语句，合并为一条。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 推荐</span><br><span class="line">INSERT INTO tb_test VALUES (1,&#x27;a&#x27;), (2,&#x27;b&#x27;), (3,&#x27;c&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>手动事务控制 (Manual Transaction):</p><p>如果插入数据量大（例如几千条），不要让数据库自动提交事务。手动开启事务，执行完后一次提交。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">INSERT ...;</span><br><span class="line">INSERT ...;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure></li><li><p>主键顺序插入:</p><p>数据按照主键顺序插入效率最高，减少由于页分裂 (Page Split) 带来的性能损耗。</p></li><li><p>大批量导入 (Load Data):</p><p>对于百万级以上数据，使用 LOAD DATA INFILE 指令，性能远超 INSERT。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA LOCAL INFILE &#x27;/path/to/data.sql&#x27; INTO TABLE tb_user ...;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">load data local infile &#x27;/root/load_user_100w_sort.sql&#x27; into table tb_user fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27;;</span><br><span class="line">-- fields terminated by &#x27;,&#x27;是每个数据以&#x27;,&#x27;进行分割</span><br><span class="line">-- lines terminated by &#x27;\n&#x27;是每行数据以换行符进行分割</span><br><span class="line">-- 具体分割方式依照要导入的数据排列方式而定</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="2-主键优化-Primary-Key-Optimization"><a href="#2-主键优化-Primary-Key-Optimization" class="headerlink" title="2. 主键优化 (Primary Key Optimization)"></a>2. 主键优化 (Primary Key Optimization)</h3><p><strong>核心目标：</strong> 维护B+树结构的稳定，减少空间浪费。</p><ul><li><strong>主键长度:</strong> 越短越好。二级索引的叶子节点存储的是主键值，主键越长，二级索引占用空间越大，IO效率越低。</li><li><strong>自增主键 (Auto-increment):</strong> 强烈建议使用自增ID。<ul><li><strong>优势:</strong> 顺序写入，数据直接追加到当前页，写满申请新页。</li><li><strong>避免:</strong> 尽量避免使用 UUID 做主键。UUID 无序且长，会导致频繁的<strong>页分裂</strong>（Page Split）和<strong>页合并</strong>，造成大量的磁盘随机IO和碎片。</li></ul></li><li><strong>避免修改主键:</strong> 修改主键相当于删除旧记录+插入新记录，代价极高。</li></ul><hr><h3 id="3-Order-By-优化"><a href="#3-Order-By-优化" class="headerlink" title="3. Order By 优化"></a>3. Order By 优化</h3><p><strong>核心目标:</strong> 使用 <code>Using index</code> (索引排序)，避免 <code>Using filesort</code> (文件排序)。</p><ul><li><strong>全值匹配&#x2F;最左前缀:</strong> 排序字段必须符合索引的最左前缀法则。</li><li><strong>覆盖索引:</strong> <code>SELECT</code> 的字段和 <code>ORDER BY</code> 的字段最好都能包含在索引中，避免回表查询。</li><li><strong>升降序一致性:</strong><ul><li>索引默认为 ASC。如果查询 <code>ORDER BY a ASC, b DESC</code>，在 MySQL 8.0 之前会导致 Filesort。</li><li><strong>优化:</strong> 创建联合索引时直接指定排序规则: <code>CREATE INDEX idx_a_b ON table(a ASC, b DESC);</code></li></ul></li><li><strong>Filesort 兜底:</strong> 如果不得不发生 Filesort，且数据量大，尝试增加 <code>sort_buffer_size</code> 参数，避免使用磁盘临时文件进行排序。</li></ul><hr><h3 id="4-Group-By-优化"><a href="#4-Group-By-优化" class="headerlink" title="4. Group By 优化"></a>4. Group By 优化</h3><p><strong>核心目标:</strong> 利用索引结构直接分组，避免创建临时表。</p><ul><li><strong>索引法则:</strong> 与 Order By 一致，严格遵循最左前缀法则。</li><li><strong>Where 优于 Having:</strong> 能在分组前通过 <code>WHERE</code> 过滤掉的数据，尽量不要留到 <code>HAVING</code> 中过滤。减少参与分组计算的数据量是第一原则。</li></ul><hr><h3 id="5-Limit-优化-分页优化"><a href="#5-Limit-优化-分页优化" class="headerlink" title="5. Limit 优化 (分页优化)"></a>5. Limit 优化 (分页优化)</h3><p><strong>核心目标:</strong> 解决深度分页（Deep Pagination）时的全表扫描问题。</p><p><strong>问题场景:</strong> <code>LIMIT 2000000, 10</code>。MySQL 需要排序并读取前 2,000,010 条记录，丢弃前 200万条，仅返回最后 10 条。</p><ul><li><p>方案一：覆盖索引 + 子查询 (推荐)</p><p>先在索引中快速找到对应的 ID（避免回表），然后再通过 ID 关联主表获取详情。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 优化前</span><br><span class="line">SELECT * FROM tb_sku LIMIT 2000000, 10;</span><br><span class="line"></span><br><span class="line">-- 优化后</span><br><span class="line">SELECT t.* FROM tb_sku t,</span><br><span class="line">(SELECT id FROM tb_sku ORDER BY id LIMIT 2000000, 10) a</span><br><span class="line">WHERE t.id = a.id;</span><br></pre></td></tr></table></figure></li><li><p>方案二：锚点定位 (适用连续ID)</p><p>如果ID是连续的且可以推断，直接用 Where 过滤。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tb_sku WHERE id &gt; 2000000 LIMIT 10;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="6-Count-优化"><a href="#6-Count-优化" class="headerlink" title="6. Count 优化"></a>6. Count 优化</h3><p><strong>核心目标:</strong> 了解不同 Count 写法的性能差异 (InnoDB 引擎)。</p><ul><li><strong>性能排序:</strong> <code>count(*) ≈ count(1) &gt; count(主键) &gt; count(字段)</code></li><li><strong>原理区别:</strong><ul><li><strong>count(字段):</strong> 会遍历全表，<strong>不计算 NULL 值</strong>。如果字段没有 <code>NOT NULL</code> 约束，还要一行行判断是否为 NULL，最慢。</li><li><strong>count(主键):</strong> 遍历全表，取出主键，累加。</li><li><strong>count(*):</strong> MySQL 做了专门优化，不取值，直接按行累加。InnoDB 会自动选择最小的二级索引进行遍历（成本最低）。</li></ul></li><li><strong>建议:</strong> 总是使用 <code>count(*)</code>。</li><li><strong>超大数据量:</strong> 如果需要频繁查询千万级数据的总数且允许微小误差，使用 <code>EXPLAIN</code> 的 <code>rows</code> 值估算；要求精确则需自己在 Redis 或计数表中维护计数。</li></ul><hr><h3 id="7-Update-优化"><a href="#7-Update-优化" class="headerlink" title="7. Update 优化"></a>7. Update 优化</h3><p><strong>核心目标:</strong> 避免<strong>行锁 (Row Lock)</strong> 升级为 <strong>表锁 (Table Lock)</strong>。</p><ul><li><p><strong>索引是关键:</strong> InnoDB 的行锁是加在<strong>索引</strong>上的，而不是加在记录上的。</p></li><li><p><strong>必须走索引:</strong></p><ul><li>如果 <code>UPDATE</code> 语句的 <code>WHERE</code> 条件字段<strong>建立了索引</strong>，InnoDB 会锁定对应的行（行锁），并发性能好。</li><li>如果 <code>WHERE</code> 条件字段<strong>没有索引</strong>（或索引失效），InnoDB 将被迫锁住整张表（表锁），导致其他事务无法操作该表，严重阻塞业务。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 假设 name 字段没有索引</span><br><span class="line">-- 这条语句会锁住整张表！</span><br><span class="line">UPDATE student SET name = &#x27;NewName&#x27; WHERE name = &#x27;OldName&#x27;;</span><br></pre></td></tr></table></figure></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
          <category> 学习笔记 </category>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MySQL]索引</title>
      <link href="/2026/01/15/MySQL-%E7%B4%A2%E5%BC%95/"/>
      <url>/2026/01/15/MySQL-%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-索引核心知识体系总结"><a href="#MySQL-索引核心知识体系总结" class="headerlink" title="MySQL 索引核心知识体系总结"></a>MySQL 索引核心知识体系总结</h1><h2 id="1-索引概述"><a href="#1-索引概述" class="headerlink" title="1. 索引概述"></a>1. 索引概述</h2><ul><li><strong>定义</strong>：索引（Index）是帮助 MySQL <strong>高效获取数据</strong>的数据结构（有序）。</li><li><strong>本质</strong>：空间换时间。</li><li><strong>优缺点</strong>：<ul><li><strong>优点</strong>：<ol><li>大大减少服务器扫描的数据量（降低 I&#x2F;O 成本）。</li><li>帮助服务器避免排序和临时表（降低 CPU 成本）。</li></ol></li><li><strong>缺点</strong>：<ol><li>占用磁盘空间。</li><li>降低写操作（<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>）的速度，因为需要维护索引结构。</li></ol></li></ul></li></ul><h2 id="2-索引结构-InnoDB"><a href="#2-索引结构-InnoDB" class="headerlink" title="2. 索引结构 (InnoDB)"></a>2. 索引结构 (InnoDB)</h2><p>MySQL 默认存储引擎 InnoDB 使用 <strong>B+ Tree</strong> 结构。</p><ul><li><strong>B+ Tree 特点</strong>：<ol><li><strong>非叶子节点</strong>仅存储键值（Key）和指针，不存储数据，增加了节点的度（Fan-out），树的高度通常控制在 3-4 层，减少 I&#x2F;O 次数。</li><li><strong>叶子节点</strong>存储所有数据（Key + Row Data 或 Key + PK），且叶子节点之间通过<strong>双向链表</strong>连接。</li><li><strong>扫库方便</strong>：支持范围查询，全表扫描只需遍历叶子节点链表。</li></ol></li><li><strong>为什么不用其他结构？</strong><ul><li><strong>Hash</strong>：仅支持精确匹配（<code>=</code>），不支持范围查询（<code>&gt;</code>, <code>&lt;</code>），不支持排序。</li><li><strong>二叉树&#x2F;红黑树</strong>：大数据量下树太高，磁盘 I&#x2F;O 次数过多；可能会退化成链表（二叉树）。</li><li><strong>B-Tree</strong>：非叶子节点也存数据，导致单页存储的 Key 变少，树的高度变高，I&#x2F;O 增加。</li></ul></li></ul><h2 id="3-索引分类"><a href="#3-索引分类" class="headerlink" title="3. 索引分类"></a>3. 索引分类</h2><h3 id="3-1-按物理存储分类-InnoDB-核心"><a href="#3-1-按物理存储分类-InnoDB-核心" class="headerlink" title="3.1 按物理存储分类 (InnoDB 核心)"></a>3.1 按物理存储分类 (InnoDB 核心)</h3><table><thead><tr><th><strong>分类</strong></th><th><strong>聚集索引 (Clustered Index)</strong></th><th><strong>二级索引 (Secondary Index)</strong></th></tr></thead><tbody><tr><td><strong>存储内容</strong></td><td>叶子节点存储<strong>完整行数据</strong></td><td>叶子节点存储<strong>索引列值 + 主键值</strong></td></tr><tr><td><strong>数量</strong></td><td>有且仅有一个</td><td>可以有多个</td></tr><tr><td><strong>选取规则</strong></td><td>1. 主键 (Primary Key) 2. 第一个唯一非空索引 (Unique Not Null) 3. 自动生成隐藏列 ROW_ID</td><td>除了聚集索引外的所有索引</td></tr><tr><td><strong>回表查询</strong></td><td>不需要</td><td>需要（先查二级索引拿到主键，再回聚集索引查数据），除非<strong>覆盖索引</strong></td></tr></tbody></table><h3 id="3-2-按逻辑-功能分类"><a href="#3-2-按逻辑-功能分类" class="headerlink" title="3.2 按逻辑&#x2F;功能分类"></a>3.2 按逻辑&#x2F;功能分类</h3><ul><li><strong>主键索引 (Primary)</strong>：唯一且非空。</li><li><strong>唯一索引 (Unique)</strong>：索引列值必须唯一，允许 NULL。</li><li><strong>普通索引 (Normal)</strong>：无特殊限制。</li><li><strong>全文索引 (Fulltext)</strong>：用于大文本搜索（通常用 ES 替代）。</li></ul><h3 id="3-3-按字段个数分类"><a href="#3-3-按字段个数分类" class="headerlink" title="3.3 按字段个数分类"></a>3.3 按字段个数分类</h3><ul><li><strong>单列索引</strong>：一个索引包含一个列。</li><li><strong>联合索引</strong>：一个索引包含多个列（涉及最左前缀原则）。</li></ul><h2 id="4-索引相关语法"><a href="#4-索引相关语法" class="headerlink" title="4. 索引相关语法"></a>4. 索引相关语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 创建索引</span><br><span class="line">CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (col_name [ASC|DESC], ...);</span><br><span class="line"></span><br><span class="line">-- 查看索引</span><br><span class="line">SHOW INDEX FROM table_name;</span><br><span class="line"></span><br><span class="line">-- 删除索引</span><br><span class="line">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure><h2 id="5-SQL-性能分析工具"><a href="#5-SQL-性能分析工具" class="headerlink" title="5. SQL 性能分析工具"></a>5. SQL 性能分析工具</h2><h3 id="5-1-SQL-执行频率"><a href="#5-1-SQL-执行频率" class="headerlink" title="5.1 SQL 执行频率"></a>5.1 SQL 执行频率</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GLOBAL STATUS LIKE &#x27;Com_______&#x27;;</span><br></pre></td></tr></table></figure><ul><li>查看 <code>Com_select</code>, <code>Com_insert</code>, <code>Com_update</code>, <code>Com_delete</code> 的数值，判断系统是读多写少还是写多读少，决定优化方向。</li></ul><h3 id="5-2-慢查询日志-Slow-Query-Log"><a href="#5-2-慢查询日志-Slow-Query-Log" class="headerlink" title="5.2 慢查询日志 (Slow Query Log)"></a>5.2 慢查询日志 (Slow Query Log)</h3><ul><li><strong>作用</strong>：记录执行时间超过 <code>long_query_time</code>（默认 10s）的 SQL。</li><li><strong>配置</strong>：<code>/etc/my.cnf</code> 中设置 <code>slow_query_log=1</code> 和 <code>long_query_time=2</code> (示例)。</li><li><strong>分析</strong>：定位出拖慢系统的具体 SQL 语句。</li></ul><h3 id="5-3-Profile-详情"><a href="#5-3-Profile-详情" class="headerlink" title="5.3 Profile 详情"></a>5.3 Profile 详情</h3><ul><li><strong>作用</strong>：查看 SQL 执行在每一个阶段（CPU、IO、Context Switch）的耗时。</li><li><strong>命令</strong>：<ul><li><code>SET profiling = 1;</code> (开启)</li><li><code>SHOW PROFILES;</code> (查看最近 SQL 列表)</li><li><code>SHOW PROFILE FOR QUERY query_id;</code> (查看具体资源消耗)</li></ul></li></ul><h3 id="5-4-EXPLAIN-执行计划-核心"><a href="#5-4-EXPLAIN-执行计划-核心" class="headerlink" title="5.4 EXPLAIN 执行计划 (核心)"></a>5.4 EXPLAIN 执行计划 (核心)</h3><p>使用 <code>EXPLAIN SELECT ...</code> 分析查询。关注核心字段：</p><ol><li><strong>type (访问类型)</strong>：性能由好到差排序：<ul><li><code>NULL</code> (不查表)</li><li><code>system</code> (系统表 1 行)</li><li><code>const</code> (主键&#x2F;唯一索引等值查询)</li><li><code>eq_ref</code> (主键&#x2F;唯一索引关联)</li><li><code>ref</code> (非唯一索引等值查询)</li><li><code>range</code> (索引范围查询)</li><li><code>index</code> (全索引扫描)</li><li><code>all</code> (全表扫描)</li><li><strong>目标</strong>：至少达到 <code>range</code>，最好是 <code>ref</code>。</li></ul></li><li><strong>possible_keys</strong>：可能用到的索引。</li><li><strong>key</strong>：实际用到的索引。</li><li><strong>key_len</strong>：索引使用的字节数（越短越好，用于检查联合索引是否完全生效）。</li><li><strong>Extra</strong>：<ul><li><code>Using index</code>：<strong>好</strong>。使用了覆盖索引，无需回表。</li><li><code>Using where</code>：需要过滤。</li><li><code>Using temporary</code>：<strong>差</strong>。使用了临时表（常见于 group by）。</li><li><code>Using filesort</code>：<strong>差</strong>。需要文件排序（常见于 order by 未命中索引）。</li></ul></li></ol><h2 id="6-索引的使用与失效场景"><a href="#6-索引的使用与失效场景" class="headerlink" title="6. 索引的使用与失效场景"></a>6. 索引的使用与失效场景</h2><h3 id="6-1-最左前缀法则-联合索引"><a href="#6-1-最左前缀法则-联合索引" class="headerlink" title="6.1 最左前缀法则 (联合索引)"></a>6.1 最左前缀法则 (联合索引)</h3><ul><li>查询从索引的<strong>最左列</strong>开始，<strong>不能跳过</strong>索引中的列。</li><li>如果跳过某一列，后面的列索引失效。</li><li><strong>范围查询右侧失效</strong>：如果遇到范围查询 (<code>&gt;</code>, <code>&lt;</code>)，则<strong>该列之后</strong>的列索引失效。（<code>&gt;=</code>、<code>&lt;=</code> 通常不会失效）。</li></ul><h3 id="6-2-常见索引失效情况"><a href="#6-2-常见索引失效情况" class="headerlink" title="6.2 常见索引失效情况"></a>6.2 常见索引失效情况</h3><ol><li><strong>函数运算</strong>：<code>WHERE substring(name, 1, 2) = &#39;ab&#39;</code>（对索引列做运算）。</li><li><strong>字符串不加引号</strong>：<code>WHERE phone = 123</code>（发生隐式类型转换）。</li><li><strong>模糊查询</strong>：<code>LIKE &#39;%abc&#39;</code>（头部模糊匹配失效，<code>&#39;abc%&#39;</code> 走索引）。</li><li><strong>OR 连接</strong>：<code>OR</code> 两侧只要有一侧没有索引，涉及的索引全部失效。</li><li><strong>数据分布影响</strong>：如果 MySQL 评估全表扫描比走索引快（例如表中绝大多数数据都符合条件），则放弃索引。</li></ol><h3 id="6-3-覆盖索引-Covering-Index"><a href="#6-3-覆盖索引-Covering-Index" class="headerlink" title="6.3 覆盖索引 (Covering Index)"></a>6.3 覆盖索引 (Covering Index)</h3><ul><li><strong>定义</strong>：查询的列 (<code>SELECT</code> 后的列) 刚好都在索引中，不需要回表查询。</li><li><strong>建议</strong>：尽量避免 <code>SELECT *</code>，指定必要列，争取命中覆盖索引（Extra: <code>Using index</code>）。</li></ul><h3 id="6-4-前缀索引"><a href="#6-4-前缀索引" class="headerlink" title="6.4 前缀索引"></a>6.4 前缀索引</h3><ul><li>针对 <code>VARCHAR</code>, <code>TEXT</code> 等长字符串，只对前 N 个字符建立索引，以节省空间。</li><li>语法：<code>CREATE INDEX idx_name ON table(column(n));</code></li></ul><h2 id="7-索引的设计原则"><a href="#7-索引的设计原则" class="headerlink" title="7. 索引的设计原则"></a>7. 索引的设计原则</h2><ol><li><p><strong>针对性</strong>：对查询频次高、数据量大（&gt;100万行）的表建立索引。</p></li><li><p><strong>字段选择</strong>：</p><ul><li><code>WHERE</code> 子句中的过滤条件字段。</li><li><code>ORDER BY</code>、<code>GROUP BY</code> 涉及的字段。</li></ul></li><li><p><strong>区分度</strong>：选择区分度高（唯一性高）的列（如 UUID、手机号）。区分度低的列（如性别、状态）不适合建单列索引。</p></li><li><p><strong>联合索引优先</strong>：尽量使用联合索引，利用覆盖索引机制，减少回表。</p></li><li><p><strong>字符串优化</strong>：长字符串使用前缀索引。</p></li><li><p><strong>控制数量</strong>：索引不是越多越好，过多的索引会拖慢写性能并增加优化器负担。</p></li><li><p><strong>非空约束</strong>：尽量将字段设为 <code>NOT NULL</code>，有利于优化器确定索引效率。</p><h2 id="8-SQL-提示-SQL-Hints"><a href="#8-SQL-提示-SQL-Hints" class="headerlink" title="8. SQL 提示 (SQL Hints)"></a>8. SQL 提示 (SQL Hints)</h2><h3 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h3><ul><li><strong>定义</strong>：开发者在 SQL 语句中显式地添加指令，人为干预数据库优化器（Optimizer）对索引的选择。</li><li><strong>场景</strong>：当 MySQL 优化器生成的执行计划不是最优解（例如选错了索引，或者放弃索引走全表扫描）时使用。</li></ul><h3 id="8-2-常用语法"><a href="#8-2-常用语法" class="headerlink" title="8.2 常用语法"></a>8.2 常用语法</h3><p>SQL 提示需紧跟在表名之后。</p><h4 id="1-USE-INDEX-建议"><a href="#1-USE-INDEX-建议" class="headerlink" title="1. USE INDEX (建议)"></a>1. USE INDEX (建议)</h4><ul><li><p><strong>含义</strong>：<strong>建议</strong> MySQL 使用指定的索引之一。</p></li><li><p><strong>特点</strong>：这只是一个参考，优化器评估后如果觉得全表扫描更快，<strong>依然可能忽略</strong>该提示。</p></li><li><p><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name USE INDEX (idx_name) WHERE col = &#x27;value&#x27;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-IGNORE-INDEX-忽略"><a href="#2-IGNORE-INDEX-忽略" class="headerlink" title="2. IGNORE INDEX (忽略)"></a>2. IGNORE INDEX (忽略)</h4><ul><li><p><strong>含义</strong>：<strong>禁止</strong> MySQL 使用指定的索引。</p></li><li><p><strong>场景</strong>：</p><ul><li>用于验证某个索引是否对查询产生负面影响。</li></ul></li></ul></li></ol><ul><li><p>当你确定全表扫描比走该索引更快时（例如数据分布极不均匀）。</p></li><li><p><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name IGNORE INDEX (idx_name) WHERE col = &#x27;value&#x27;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-FORCE-INDEX-强制"><a href="#3-FORCE-INDEX-强制" class="headerlink" title="3. FORCE INDEX (强制)"></a>3. FORCE INDEX (强制)</h4><ul><li><p><strong>含义</strong>：<strong>强制</strong> MySQL 使用指定的索引。</p></li><li><p><strong>特点</strong>：比 <code>USE INDEX</code> 语气更重。如果强制的索引无法使用，MySQL 通常会选择全表扫描作为代价，极少会忽略该指令。</p></li><li><p><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name FORCE INDEX (idx_name) WHERE col = &#x27;value&#x27;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
          <category> 学习笔记 </category>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MySQL]基础操作</title>
      <link href="/2026/01/15/MySQL-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
      <url>/2026/01/15/MySQL-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="DDL基本操作"><a href="#DDL基本操作" class="headerlink" title="DDL基本操作"></a>DDL基本操作</h1><h2 id="1-数据库操作"><a href="#1-数据库操作" class="headerlink" title="1.数据库操作"></a>1.数据库操作</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p><strong>查询所有数据库</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure><p><strong>查询当前的数据库</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATABASE();</span><br></pre></td></tr></table></figure><p><strong>创建数据库</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排列顺序];</span><br></pre></td></tr></table></figure><p><em>注：[ ]内可不写</em></p><p><strong>删除数据库</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE [IF EXISTS] 数据库名;</span><br></pre></td></tr></table></figure><p><strong>使用数据库</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure><p><strong>查询当前数据库中所有的表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure><p><strong>查询表结构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC 表名;</span><br></pre></td></tr></table></figure><p><strong>查询指定表的建表语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE TABLE 表名;</span><br></pre></td></tr></table></figure><p>###创建<br><strong>创建表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">字段1 字段1类型[COMMENT 字段1注释],</span><br><span class="line">字段1 字段1类型[COMMENT 字段1注释],</span><br><span class="line">字段1 字段1类型[COMMENT 字段1注释],</span><br><span class="line">......</span><br><span class="line">字段1 字段1类型[COMMENT 字段1注释]</span><br><span class="line">)[COMMENT 表注释]</span><br></pre></td></tr></table></figure><p><em>注：[…]内为可选项   最后一个字段后没有逗号<br>在MySQL中字符串数据类型varchar(…)为变长字符串括号内为字符最大容量</em></p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table tb_test1(</span><br><span class="line">    id int comment&#x27;编号&#x27;,</span><br><span class="line">    name varchar(50) comment &#x27;姓名&#x27;,</span><br><span class="line">    age int comment &#x27;年龄&#x27;,</span><br><span class="line">    gender varchar(1) comment &#x27;性别&#x27;</span><br><span class="line">    ) comment &#x27;测试表01&#x27;;</span><br></pre></td></tr></table></figure><p><strong>经过<code>DESC 表名;</code>语句的显示效果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field  | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| id     | int         | YES  |     | NULL    |       |</span><br><span class="line">| name   | varchar(50) | YES  |     | NULL    |       |</span><br><span class="line">| age    | int         | YES  |     | NULL    |       |</span><br><span class="line">| gender | varchar(1)  | YES  |     | NULL    |       |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br></pre></td></tr></table></figure><p><strong>经过<code>SHOW CREATE TABLE 表名;</code>语句的显示效果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Table    | Create Table                                                                                                                                                                                                                                                                                         |</span><br><span class="line">+----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| tb_test1 | CREATE TABLE `tb_test1` (</span><br><span class="line">  `id` int DEFAULT NULL COMMENT &#x27;编号&#x27;,</span><br><span class="line">  `name` varchar(50) DEFAULT NULL COMMENT &#x27;姓名&#x27;,</span><br><span class="line">  `age` int DEFAULT NULL COMMENT &#x27;年龄&#x27;,</span><br><span class="line">  `gender` varchar(1) DEFAULT NULL COMMENT &#x27;性别&#x27;</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=&#x27;测试表01&#x27; |</span><br><span class="line">+----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p><strong>添加字段</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];</span><br></pre></td></tr></table></figure><p><strong>修改原有字段数据类型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);</span><br></pre></td></tr></table></figure><p><strong>查询表结构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</span><br></pre></td></tr></table></figure><p><strong>删除字段</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP 字段名;</span><br></pre></td></tr></table></figure><p><strong>修改表名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 RENAME TO 新表名;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><strong>删除表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE [IF EXISTS] 表名;</span><br></pre></td></tr></table></figure><p><strong>删除指定表，并重新创建该表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE 表名;</span><br></pre></td></tr></table></figure><h3 id="1-数值类型-Numeric-Types"><a href="#1-数值类型-Numeric-Types" class="headerlink" title="1. 数值类型 (Numeric Types)"></a>1. 数值类型 (Numeric Types)</h3><p>这里有一个重点：<strong>Java 的 <code>long</code> 对应 MySQL 的 <code>BIGINT</code></strong>，<strong>钱（货币）一定要用 <code>DECIMAL</code></strong>。</p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>大小 (存储空间)</strong></th><th><strong>描述与应用场景</strong></th><th><strong>对应 Java 类型</strong></th></tr></thead><tbody><tr><td><code>TINYINT</code></td><td>1 byte</td><td>非常小的整数。常用 <code>TINYINT(1)</code> 来表示 <strong>布尔值 (Boolean)</strong> (0为假, 1为真)。</td><td><code>Byte</code> &#x2F; <code>Boolean</code></td></tr><tr><td><code>SMALLINT</code></td><td>2 bytes</td><td>小整数。范围约 $\pm 3$ 万。</td><td><code>Short</code></td></tr><tr><td><code>MEDIUMINT</code></td><td>3 bytes</td><td>中等大小整数。范围约 $\pm 800$ 万 (很少用)。</td><td><code>Integer</code></td></tr><tr><td><code>INT</code> &#x2F; <code>INTEGER</code></td><td>4 bytes</td><td><strong>最常用的整数</strong>。范围约 $\pm 21$ 亿。</td><td><code>Integer</code></td></tr><tr><td><code>BIGINT</code></td><td>8 bytes</td><td>极大整数。通常用于 <strong>主键 ID</strong> 或像推特点击量这种大数。</td><td><code>Long</code></td></tr><tr><td><code>FLOAT</code></td><td>4 bytes</td><td>单精度浮点数。<strong>不精确</strong>，存在精度丢失问题。</td><td><code>Float</code></td></tr><tr><td><code>DOUBLE</code></td><td>8 bytes</td><td>双精度浮点数。精度比 Float 高，但仍 <strong>不精确</strong>。</td><td><code>Double</code></td></tr><tr><td><code>DECIMAL(M, D)</code></td><td>变长 (取决于M)</td><td><strong>定点数</strong> (精确值)。M是总位数，D是小数位。<strong>涉及金额&#x2F;财务必用此类型</strong>。</td><td><code>BigDecimal</code></td></tr></tbody></table><hr><h3 id="2-字符串与二进制类型-String-Binary-Types"><a href="#2-字符串与二进制类型-String-Binary-Types" class="headerlink" title="2. 字符串与二进制类型 (String &amp; Binary Types)"></a>2. 字符串与二进制类型 (String &amp; Binary Types)</h3><p>重点区分：<strong><code>CHAR</code> 是定长（死板），<code>VARCHAR</code> 是变长（灵活）。</strong></p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>大小 (存储空间)</strong></th><th><strong>描述与应用场景</strong></th><th><strong>对应 Java 类型</strong></th></tr></thead><tbody><tr><td><code>CHAR(M)</code></td><td>M bytes (0-255)</td><td><strong>定长字符串</strong>。如果你存 “A”，它也会占满 M 个空间。适合存固定长度数据 (如身份证、手机号、性别)。速度快但费空间。</td><td><code>String</code></td></tr><tr><td><code>VARCHAR(M)</code></td><td>变长 (0-65535)</td><td><strong>变长字符串</strong>。存多少占多少+长度标识位。<strong>开发中最常用的字符串类型</strong> (如用户名、地址)。</td><td><code>String</code></td></tr><tr><td><code>TINYTEXT</code></td><td>0-255 bytes</td><td>短文本。</td><td><code>String</code></td></tr><tr><td><code>TEXT</code></td><td>0-64 KB</td><td>长文本。适合存文章内容、评论、简介。</td><td><code>String</code></td></tr><tr><td><code>MEDIUMTEXT</code></td><td>0-16 MB</td><td>中长文本。适合存书的内容。</td><td><code>String</code></td></tr><tr><td><code>LONGTEXT</code></td><td>0-4 GB</td><td>极长文本。甚至可以把一整本百科全书存进去。</td><td><code>String</code></td></tr><tr><td><code>BLOB</code> 系列</td><td>变长</td><td>二进制大对象。用于存图片、音频等 (通常<strong>不建议</strong>直接存数据库，建议存文件路径)。</td><td><code>byte[]</code></td></tr><tr><td><code>JSON</code></td><td>变长</td><td><strong>JSON 文档</strong>。MySQL 5.7+ 支持。适合存非结构化数据，能直接解析 Key-Value。</td><td><code>String</code> &#x2F; Object</td></tr></tbody></table><hr><h3 id="3-日期与时间类型-Date-Time-Types"><a href="#3-日期与时间类型-Date-Time-Types" class="headerlink" title="3. 日期与时间类型 (Date &amp; Time Types)"></a>3. 日期与时间类型 (Date &amp; Time Types)</h3><p>重点区分：<strong><code>TIMESTAMP</code> 会随时区变化，<code>DATETIME</code> 不会。</strong></p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>大小 (存储空间)</strong></th><th><strong>描述与应用场景</strong></th><th><strong>对应 Java 类型</strong></th></tr></thead><tbody><tr><td><code>DATE</code></td><td>3 bytes</td><td>仅日期。格式：<code>YYYY-MM-DD</code>。如：生日 <code>1990-01-01</code>。</td><td><code>java.sql.Date</code> &#x2F; <code>LocalDate</code></td></tr><tr><td><code>TIME</code></td><td>3 bytes</td><td>仅时间。格式：<code>HH:MM:SS</code>。如：时长 <code>12:30:00</code>。</td><td><code>java.sql.Time</code> &#x2F; <code>LocalTime</code></td></tr><tr><td><code>YEAR</code></td><td>1 byte</td><td>年份。格式：<code>YYYY</code> (1901-2155)。</td><td><code>Integer</code> &#x2F; <code>Year</code></td></tr><tr><td><code>DATETIME</code></td><td>8 bytes</td><td><strong>日期+时间</strong>。范围：1000年到9999年。<strong>绝对时间</strong>，存进去是什么，取出来就是什么，不理会时区。</td><td><code>LocalDateTime</code></td></tr><tr><td><code>TIMESTAMP</code></td><td>4 bytes</td><td><strong>时间戳</strong>。范围：1970年到2038年。<strong>涉及时区转换</strong> (存进去会转成UTC，取出来转回当前时区)。适合记录“创建时间&#x2F;修改时间”。</td><td><code>Timestamp</code> &#x2F; <code>Instant</code></td></tr></tbody></table><hr><h1 id="DML基础操作"><a href="#DML基础操作" class="headerlink" title="DML基础操作"></a>DML基础操作</h1><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p><strong>给指定字段添加数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 (字段名1,字段名2,字段名3,...) VALUES (值1,值2,值3,...);</span><br></pre></td></tr></table></figure><p><strong>给全部字段添加数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 VALUES (值1,值2,值3,...);</span><br></pre></td></tr></table></figure><p><strong>批量添加数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 (字段名1,字段名2,字段名3,...) VALUES (值1,值2,值3,...),(值1,值2,值3,...),...;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 VALUES (值1,值2,值3,...),(值1,值2,值3,...),(值1,值2,值3,...),...;</span><br></pre></td></tr></table></figure><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM 表名 WHERE 条件</span><br></pre></td></tr></table></figure><p><em>注：</em></p><p><em>1.若不写where语句则是删除整张表的所有数据</em></p><p><em>2.delete不能删除某一个字段的值 可以用updata设置成null</em></p><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATA 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... WHERE 条件;</span><br></pre></td></tr></table></figure><p><em>注：要是不写where语句则是修改整张表的字段的值</em></p><hr><h1 id="DQL基本操作"><a href="#DQL基本操作" class="headerlink" title="DQL基本操作"></a>DQL基本操作</h1><h3 id="1-基本查询"><a href="#1-基本查询" class="headerlink" title="1.基本查询"></a>1.基本查询</h3><p><strong>查询多个字段</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段1 AS &#x27;别名&#x27;,字段2 &#x27;别名&#x27;,字段3,...FROM 表名;</span><br><span class="line">-- 别名可以不写 如若想写别名显示 可以写AS也可不写</span><br></pre></td></tr></table></figure><p><strong>去除重复记录</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT 字段列表 FROM 表名;</span><br></pre></td></tr></table></figure><h3 id="2-条件查询"><a href="#2-条件查询" class="headerlink" title="2.条件查询"></a>2.条件查询</h3><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 WHERE 条件列表;</span><br></pre></td></tr></table></figure><p><strong>条件</strong></p><table><thead><tr><th align="center">比较运算符</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&gt;&#x3D;</td><td align="center">大于等于</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&lt;&#x3D;</td><td align="center">小于等于</td></tr><tr><td align="center">&#x3D;</td><td align="center">等于</td></tr><tr><td align="center">&lt;&gt; 或 !&#x3D;</td><td align="center">不等于</td></tr><tr><td align="center">BETWEEN 最小值 AND 最大值</td><td align="center">在某个范围之内(含最大最小值)</td></tr><tr><td align="center">IN(…)</td><td align="center">至少符合IN列表中一项的数据</td></tr><tr><td align="center">LIKE 占位符</td><td align="center">模糊匹配：’_’  : 任意一个字符  ‘%’ : 任意个字符</td></tr><tr><td align="center">IS NULL</td><td align="center">是NULL</td></tr></tbody></table><hr><table><thead><tr><th align="center">逻辑运算符</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">AND 或 &amp;&amp;</td><td align="center">与</td></tr><tr><td align="center">OR 或 ||</td><td align="center">或</td></tr><tr><td align="center">NOT 或！</td><td align="center">非</td></tr></tbody></table><h3 id="3-聚合函数"><a href="#3-聚合函数" class="headerlink" title="3.聚合函数"></a>3.聚合函数</h3><p><code>将一列数据作为一个整体 进行纵向计算</code></p><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">count</td><td align="center">统计数量</td></tr><tr><td align="center">max</td><td align="center">最大值</td></tr><tr><td align="center">min</td><td align="center">最小值</td></tr><tr><td align="center">avg</td><td align="center">平均值</td></tr><tr><td align="center">sum</td><td align="center">求和</td></tr></tbody></table><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 聚合函数(字符列表) FROM 表名;</span><br></pre></td></tr></table></figure><p><em>注：null值不参与聚合函数的运算！</em></p><h3 id="4-分组查询"><a href="#4-分组查询" class="headerlink" title="4.分组查询"></a>4.分组查询</h3><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后的过滤条件];</span><br></pre></td></tr></table></figure><p><strong>WHERE与HAVING的区别</strong></p><p>where是在分组之前进行的过滤 满足where条件的才可进行分组</p><p>having是分组之后进行的过滤</p><p><strong>执行顺序</strong></p><p><code>where &gt; 聚合函数 &gt; having</code></p><h3 id="5-排序查询"><a href="#5-排序查询" class="headerlink" title="5.排序查询"></a>5.排序查询</h3><p><strong>1.语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2...;</span><br></pre></td></tr></table></figure><p><strong>2.排序方式</strong></p><p>1.升序：ASC（默认值）</p><p>2.降序：DESC</p><h3 id="6-分页查询"><a href="#6-分页查询" class="headerlink" title="6.分页查询"></a>6.分页查询</h3><p><strong>1.语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询录数;</span><br></pre></td></tr></table></figure><p><strong>2.示例</strong></p><p>若查询的数据每一页有十个数据，那么我查询第一页的代码是</p><p><code>SELECT 字段列表 FROM 表名 LIMIT 0, 10;</code></p><p>如果是第一页则<code>起始索引</code>可以省略：</p><p><code>SELECT 字段列表 FROM 表名 LIMIT 10;</code></p><p>查询第二页的代码为：</p><p><code>SELECT 字段列表 FROM 表名 LIMIT 10, 10;</code></p><p>查询第n页的<code>起始索引</code>可以通过<code>（页数 - 1）* 查询录数</code>计算得出</p><p><em>注：索引是从0开始的！</em></p><h3 id="7-DQL的编写顺序"><a href="#7-DQL的编写顺序" class="headerlink" title="7.DQL的编写顺序"></a>7.DQL的编写顺序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">FROM</span><br><span class="line">WHERE</span><br><span class="line">GROUP BY</span><br><span class="line">HAVING</span><br><span class="line">ORDER BY</span><br><span class="line">LIMIT</span><br></pre></td></tr></table></figure><h3 id="8-DQL的执行顺序"><a href="#8-DQL的执行顺序" class="headerlink" title="8.DQL的执行顺序"></a>8.DQL的执行顺序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM</span><br><span class="line">WHERE</span><br><span class="line">GROUP BY</span><br><span class="line">HAVING</span><br><span class="line">SELECT</span><br><span class="line">ORDER BY</span><br><span class="line">LIMIT</span><br></pre></td></tr></table></figure><hr><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h3 id="1-字符串函数"><a href="#1-字符串函数" class="headerlink" title="1.字符串函数"></a>1.字符串函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-- 字符串拼接</span><br><span class="line">select concat(&#x27;1&#x27;,&#x27;23&#x27;); -- 123</span><br><span class="line"></span><br><span class="line">-- 转换为小写</span><br><span class="line">select lower(&#x27;Hello!&#x27;); -- hello!</span><br><span class="line"></span><br><span class="line">-- 转换为大写</span><br><span class="line">select upper(&#x27;Hello!&#x27;); -- HELLO!</span><br><span class="line"></span><br><span class="line">-- 左填充</span><br><span class="line">select lpad(&#x27;1&#x27;,5,&#x27;0&#x27;); -- 00001</span><br><span class="line"></span><br><span class="line">-- 右填充</span><br><span class="line">select rpad(&#x27;1&#x27;,5,&#x27;0&#x27;); -- 10000</span><br><span class="line"></span><br><span class="line">-- 去掉字符串头和尾的空格</span><br><span class="line">select trim(&#x27; 1 2 3 &#x27;); -- 123</span><br><span class="line"></span><br><span class="line">-- 截取字符串</span><br><span class="line">select substr(&#x27;123456&#x27;,1,3); -- 123</span><br></pre></td></tr></table></figure><h3 id="2-数值函数"><a href="#2-数值函数" class="headerlink" title="2.数值函数"></a>2.数值函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- 向上取整</span><br><span class="line">select ceil(1.1); -- 2</span><br><span class="line"></span><br><span class="line">-- 向下取整</span><br><span class="line">select floor(1.9); -- 1</span><br><span class="line"></span><br><span class="line">-- x/y的模</span><br><span class="line">select mod(7,3); -- 1</span><br><span class="line"></span><br><span class="line">-- 返回0~1内的随机数</span><br><span class="line">select rand(); -- 0.05256707784958843</span><br><span class="line"></span><br><span class="line">-- 把x四舍五入，保留y位小数</span><br><span class="line">select round(1.578, 2); -- 1.58</span><br></pre></td></tr></table></figure><h3 id="3-日期函数"><a href="#3-日期函数" class="headerlink" title="3.日期函数"></a>3.日期函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-- 返回当前日期</span><br><span class="line">select curdate(); -- 2026-01-13</span><br><span class="line"></span><br><span class="line">-- 返回当前时间</span><br><span class="line">select curtime(); -- 16:23:15</span><br><span class="line"></span><br><span class="line">-- 返回当前日期和时间</span><br><span class="line">select now(); -- 2026-01-13 16:24:00</span><br><span class="line"></span><br><span class="line">-- 获取传入date的年份</span><br><span class="line">select year(now()); -- 2026</span><br><span class="line"></span><br><span class="line">-- 获取传入date的月份</span><br><span class="line">select month(now()); -- 1</span><br><span class="line"></span><br><span class="line">-- 获取传入date的日份</span><br><span class="line">select day(now()); -- 13</span><br><span class="line"></span><br><span class="line">-- 返回传入的日期加上传入的时间间隔之后的时间值 INTERVAL是固定值</span><br><span class="line">select date_add(now(), INTERVAL 30 year); -- 2056-01-13 16:26:51</span><br><span class="line"></span><br><span class="line">-- 返回两个时间之间的间隔</span><br><span class="line">select datediff(now(), &#x27;2007-6-4&#x27;); -- 6798</span><br></pre></td></tr></table></figure><h3 id="4-流程函数"><a href="#4-流程函数" class="headerlink" title="4.流程函数"></a>4.流程函数</h3><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">if(value, t, f)</td><td align="center">如果value为true，返回t，否则返回f</td></tr><tr><td align="center">ifnull(value 1, value 2)</td><td align="center">如果value 1不为空则返回value 1，否则返回value 2</td></tr><tr><td align="center">case when [val1] then [res1]…else[default] end</td><td align="center">如果val1为true,返回res1,…否则返回default默认值</td></tr><tr><td align="center">case [expr] when [val1] then [res1]…else[def] end</td><td align="center">如果expr的值等于val1,返回res1,…否则返回def</td></tr></tbody></table><hr><h1 id="多表查询例题"><a href="#多表查询例题" class="headerlink" title="多表查询例题"></a>多表查询例题</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">-- ------------------------------------&gt; 多表查询 &lt;--------------------------------------------</span><br><span class="line">-- 准备数据</span><br><span class="line">create table dept(</span><br><span class="line">                     id   int auto_increment comment &#x27;ID&#x27; primary key,</span><br><span class="line">                     name varchar(50) not null comment &#x27;部门名称&#x27;</span><br><span class="line">)comment &#x27;部门表&#x27;;</span><br><span class="line"></span><br><span class="line">create table emp(</span><br><span class="line">                    id  int auto_increment comment &#x27;ID&#x27; primary key,</span><br><span class="line">                    name varchar(50) not null comment &#x27;姓名&#x27;,</span><br><span class="line">                    age  int comment &#x27;年龄&#x27;,</span><br><span class="line">                    job varchar(20) comment &#x27;职位&#x27;,</span><br><span class="line">                    salary int comment &#x27;薪资&#x27;,</span><br><span class="line">                    entrydate date comment &#x27;入职时间&#x27;,</span><br><span class="line">                    managerid int comment &#x27;直属领导ID&#x27;,</span><br><span class="line">                    dept_id int comment &#x27;部门ID&#x27;</span><br><span class="line">)comment &#x27;员工表&#x27;;</span><br><span class="line"></span><br><span class="line">-- 添加外键</span><br><span class="line">alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id);</span><br><span class="line"></span><br><span class="line">INSERT INTO dept (id, name) VALUES (1, &#x27;研发部&#x27;), (2, &#x27;市场部&#x27;),(3, &#x27;财务部&#x27;), (4, &#x27;销售部&#x27;), (5, &#x27;总经办&#x27;), (6, &#x27;人事部&#x27;);</span><br><span class="line">INSERT INTO emp (id, name, age, job,salary, entrydate, managerid, dept_id) VALUES</span><br><span class="line">                                                                               (1, &#x27;金庸&#x27;, 66, &#x27;总裁&#x27;,20000, &#x27;2000-01-01&#x27;, null,5),</span><br><span class="line"></span><br><span class="line">                                                                               (2, &#x27;张无忌&#x27;, 20, &#x27;项目经理&#x27;,12500, &#x27;2005-12-05&#x27;, 1,1),</span><br><span class="line">                                                                               (3, &#x27;杨逍&#x27;, 33, &#x27;开发&#x27;, 8400,&#x27;2000-11-03&#x27;, 2,1),</span><br><span class="line">                                                                               (4, &#x27;韦一笑&#x27;, 48, &#x27;开发&#x27;,11000, &#x27;2002-02-05&#x27;, 2,1),</span><br><span class="line">                                                                               (5, &#x27;常遇春&#x27;, 43, &#x27;开发&#x27;,10500, &#x27;2004-09-07&#x27;, 3,1),</span><br><span class="line">                                                                               (6, &#x27;小昭&#x27;, 19, &#x27;程序员鼓励师&#x27;,6600, &#x27;2004-10-12&#x27;, 2,1),</span><br><span class="line"></span><br><span class="line">                                                                               (7, &#x27;灭绝&#x27;, 60, &#x27;财务总监&#x27;,8500, &#x27;2002-09-12&#x27;, 1,3),</span><br><span class="line">                                                                               (8, &#x27;周芷若&#x27;, 19, &#x27;会计&#x27;,48000, &#x27;2006-06-02&#x27;, 7,3),</span><br><span class="line">                                                                               (9, &#x27;丁敏君&#x27;, 23, &#x27;出纳&#x27;,5250, &#x27;2009-05-13&#x27;, 7,3),</span><br><span class="line"></span><br><span class="line">                                                                               (10, &#x27;赵敏&#x27;, 20, &#x27;市场部总监&#x27;,12500, &#x27;2004-10-12&#x27;, 1,2),</span><br><span class="line">                                                                               (11, &#x27;鹿杖客&#x27;, 56, &#x27;职员&#x27;,3750, &#x27;2006-10-03&#x27;, 10,2),</span><br><span class="line">                                                                               (12, &#x27;鹤笔翁&#x27;, 19, &#x27;职员&#x27;,3750, &#x27;2007-05-09&#x27;, 10,2),</span><br><span class="line">                                                                               (13, &#x27;方东白&#x27;, 19, &#x27;职员&#x27;,5500, &#x27;2009-02-12&#x27;, 10,2),</span><br><span class="line"></span><br><span class="line">                                                                               (14, &#x27;张三丰&#x27;, 88, &#x27;销售总监&#x27;,14000, &#x27;2004-10-12&#x27;, 1,4),</span><br><span class="line">                                                                               (15, &#x27;俞莲舟&#x27;, 38, &#x27;销售&#x27;,4600, &#x27;2004-10-12&#x27;, 14,4),</span><br><span class="line">                                                                               (16, &#x27;宋远桥&#x27;, 40, &#x27;销售&#x27;,4600, &#x27;2004-10-12&#x27;, 14,4),</span><br><span class="line">                                                                               (17, &#x27;陈友谅&#x27;, 42, null,2000, &#x27;2011-10-12&#x27;, 1,null);</span><br><span class="line">-- ---------------------------------------&gt; 多表查询案例 &lt;----------------------------------</span><br><span class="line">create table salgrade(</span><br><span class="line">                         grade int,</span><br><span class="line">                         losal int,</span><br><span class="line">                         hisal int</span><br><span class="line">) comment &#x27;薪资等级表&#x27;;</span><br><span class="line"></span><br><span class="line">insert into salgrade values (1,0,3000);</span><br><span class="line">insert into salgrade values (2,3001,5000);</span><br><span class="line">insert into salgrade values (3,5001,8000);</span><br><span class="line">insert into salgrade values (4,8001,10000);</span><br><span class="line">insert into salgrade values (5,10001,15000);</span><br><span class="line">insert into salgrade values (6,15001,20000);</span><br><span class="line">insert into salgrade values (7,20001,25000);</span><br><span class="line">insert into salgrade values (8,25001,30000);</span><br><span class="line"></span><br><span class="line">-- 1. 查询员工的姓名、年龄、职位、部门信息 （隐式内连接）</span><br><span class="line">select e.name,e.age,e.job,d.name from emp e left join dept d on e.dept_id = d.id;</span><br><span class="line"></span><br><span class="line">select e.name,e.age,e.job,d.name from emp e , dept d where e.dept_id = d.id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 2. 查询年龄小于30岁的员工的姓名、年龄、职位、部门信息（显式内连接）</span><br><span class="line">select e.name,e.age,e.job,d.name from (select * from emp where emp.age &lt; 30) e left join dept d on e.dept_id = d.id;</span><br><span class="line">select e.name,e.age,e.job,d.name from emp e join dept d on e.dept_id = d.id where e.age &lt; 30;</span><br><span class="line"></span><br><span class="line">-- 3. 查询拥有员工的部门ID、部门名称</span><br><span class="line">select distinct d.id,d.name from emp e , dept d where e.dept_id = d.id;</span><br><span class="line"></span><br><span class="line">-- 4. 查询所有年龄大于40岁的员工, 及其归属的部门名称; 如果员工没有分配部门, 也需要展示出来</span><br><span class="line">select e.*,d.name from emp e left join dept d on e.dept_id = d.id where e.age &gt; 40;</span><br><span class="line"></span><br><span class="line">-- 5. 查询所有员工的工资等级</span><br><span class="line">select e.*,s.grade from emp e,salgrade s where e.salary &gt;= s.losal and e.salary &lt;= s.hisal;</span><br><span class="line">select e.*,s.grade from emp e,salgrade s where e.salary between s.losal and s.hisal;</span><br><span class="line"></span><br><span class="line">-- 6. 查询 &quot;研发部&quot; 所有员工的信息及 工资等级</span><br><span class="line">select e.*,d.name,s.grade</span><br><span class="line">from</span><br><span class="line">    emp e, dept d, salgrade s</span><br><span class="line">where</span><br><span class="line">    e.dept_id = d.id and e.salary between s.losal and s.hisal and d.name = &#x27;研发部&#x27;;</span><br><span class="line"></span><br><span class="line">-- 7. 查询 &quot;研发部&quot; 员工的平均工资</span><br><span class="line">select</span><br><span class="line">    avg(e.salary)</span><br><span class="line">from</span><br><span class="line">    emp e, dept d</span><br><span class="line">where</span><br><span class="line">    e.dept_id = d.id and</span><br><span class="line">    d.name = &#x27;研发部&#x27;;</span><br><span class="line"></span><br><span class="line">-- 8. 查询工资比 &quot;灭绝&quot; 高的员工信息。</span><br><span class="line">select</span><br><span class="line">    *</span><br><span class="line">from</span><br><span class="line">    emp e</span><br><span class="line">where</span><br><span class="line">    e.salary &gt; (select e.salary from emp e where e.name = &#x27;灭绝&#x27;);</span><br><span class="line"></span><br><span class="line">-- 9. 查询比平均薪资高的员工信息</span><br><span class="line">select</span><br><span class="line">    *</span><br><span class="line">from</span><br><span class="line">    emp</span><br><span class="line">where</span><br><span class="line">    salary &gt; (select avg(salary) from emp);</span><br><span class="line"></span><br><span class="line">-- 10. 查询低于本部门平均工资的员工信息</span><br><span class="line">select *</span><br><span class="line">from emp e1</span><br><span class="line">where</span><br><span class="line">    e1.salary &lt; (select avg(e.salary) from emp e where e.dept_id = e1.dept_id);</span><br><span class="line"></span><br><span class="line">-- 11. 查询所有的部门信息, 并统计部门的员工人数</span><br><span class="line">select d.*, (select count(*) from emp e where e.dept_id = d.id) &#x27;人数&#x27; from dept d;</span><br><span class="line"></span><br><span class="line">select d.id,d.name,count(e.id) from dept d left join emp e on d.id = e.dept_id group by d.id,d.name;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
          <category> 学习笔记 </category>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

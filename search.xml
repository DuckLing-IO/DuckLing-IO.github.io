<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[MySQL]优化</title>
      <link href="/2026/01/15/MySQL-SQL%E4%BC%98%E5%8C%96/"/>
      <url>/2026/01/15/MySQL-SQL%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="1-插入数据优化-Insert-Optimization"><a href="#1-插入数据优化-Insert-Optimization" class="headerlink" title="1. 插入数据优化 (Insert Optimization)"></a>1. 插入数据优化 (Insert Optimization)</h3><p><strong>核心目标：</strong> 减少磁盘I&#x2F;O交互次数，降低日志刷新频率。</p><ul><li><p>批量插入 (Batch Insert):</p><p>不要使用多条 INSERT INTO 语句，合并为一条。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 推荐</span><br><span class="line">INSERT INTO tb_test VALUES (1,&#x27;a&#x27;), (2,&#x27;b&#x27;), (3,&#x27;c&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>手动事务控制 (Manual Transaction):</p><p>如果插入数据量大（例如几千条），不要让数据库自动提交事务。手动开启事务，执行完后一次提交。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">INSERT ...;</span><br><span class="line">INSERT ...;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure></li><li><p>主键顺序插入:</p><p>数据按照主键顺序插入效率最高，减少由于页分裂 (Page Split) 带来的性能损耗。</p></li><li><p>大批量导入 (Load Data):</p><p>对于百万级以上数据，使用 LOAD DATA INFILE 指令，性能远超 INSERT。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA LOCAL INFILE &#x27;/path/to/data.sql&#x27; INTO TABLE tb_user ...;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">load data local infile &#x27;/root/load_user_100w_sort.sql&#x27; into table tb_user fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27;;</span><br><span class="line">-- fields terminated by &#x27;,&#x27;是每个数据以&#x27;,&#x27;进行分割</span><br><span class="line">-- lines terminated by &#x27;\n&#x27;是每行数据以换行符进行分割</span><br><span class="line">-- 具体分割方式依照要导入的数据排列方式而定</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="2-主键优化-Primary-Key-Optimization"><a href="#2-主键优化-Primary-Key-Optimization" class="headerlink" title="2. 主键优化 (Primary Key Optimization)"></a>2. 主键优化 (Primary Key Optimization)</h3><p><strong>核心目标：</strong> 维护B+树结构的稳定，减少空间浪费。</p><ul><li><strong>主键长度:</strong> 越短越好。二级索引的叶子节点存储的是主键值，主键越长，二级索引占用空间越大，IO效率越低。</li><li><strong>自增主键 (Auto-increment):</strong> 强烈建议使用自增ID。<ul><li><strong>优势:</strong> 顺序写入，数据直接追加到当前页，写满申请新页。</li><li><strong>避免:</strong> 尽量避免使用 UUID 做主键。UUID 无序且长，会导致频繁的<strong>页分裂</strong>（Page Split）和<strong>页合并</strong>，造成大量的磁盘随机IO和碎片。</li></ul></li><li><strong>避免修改主键:</strong> 修改主键相当于删除旧记录+插入新记录，代价极高。</li></ul><hr><h3 id="3-Order-By-优化"><a href="#3-Order-By-优化" class="headerlink" title="3. Order By 优化"></a>3. Order By 优化</h3><p><strong>核心目标:</strong> 使用 <code>Using index</code> (索引排序)，避免 <code>Using filesort</code> (文件排序)。</p><ul><li><strong>全值匹配&#x2F;最左前缀:</strong> 排序字段必须符合索引的最左前缀法则。</li><li><strong>覆盖索引:</strong> <code>SELECT</code> 的字段和 <code>ORDER BY</code> 的字段最好都能包含在索引中，避免回表查询。</li><li><strong>升降序一致性:</strong><ul><li>索引默认为 ASC。如果查询 <code>ORDER BY a ASC, b DESC</code>，在 MySQL 8.0 之前会导致 Filesort。</li><li><strong>优化:</strong> 创建联合索引时直接指定排序规则: <code>CREATE INDEX idx_a_b ON table(a ASC, b DESC);</code></li></ul></li><li><strong>Filesort 兜底:</strong> 如果不得不发生 Filesort，且数据量大，尝试增加 <code>sort_buffer_size</code> 参数，避免使用磁盘临时文件进行排序。</li></ul><hr><h3 id="4-Group-By-优化"><a href="#4-Group-By-优化" class="headerlink" title="4. Group By 优化"></a>4. Group By 优化</h3><p><strong>核心目标:</strong> 利用索引结构直接分组，避免创建临时表。</p><ul><li><strong>索引法则:</strong> 与 Order By 一致，严格遵循最左前缀法则。</li><li><strong>Where 优于 Having:</strong> 能在分组前通过 <code>WHERE</code> 过滤掉的数据，尽量不要留到 <code>HAVING</code> 中过滤。减少参与分组计算的数据量是第一原则。</li></ul><hr><h3 id="5-Limit-优化-分页优化"><a href="#5-Limit-优化-分页优化" class="headerlink" title="5. Limit 优化 (分页优化)"></a>5. Limit 优化 (分页优化)</h3><p><strong>核心目标:</strong> 解决深度分页（Deep Pagination）时的全表扫描问题。</p><p><strong>问题场景:</strong> <code>LIMIT 2000000, 10</code>。MySQL 需要排序并读取前 2,000,010 条记录，丢弃前 200万条，仅返回最后 10 条。</p><ul><li><p>方案一：覆盖索引 + 子查询 (推荐)</p><p>先在索引中快速找到对应的 ID（避免回表），然后再通过 ID 关联主表获取详情。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 优化前</span><br><span class="line">SELECT * FROM tb_sku LIMIT 2000000, 10;</span><br><span class="line"></span><br><span class="line">-- 优化后</span><br><span class="line">SELECT t.* FROM tb_sku t,</span><br><span class="line">(SELECT id FROM tb_sku ORDER BY id LIMIT 2000000, 10) a</span><br><span class="line">WHERE t.id = a.id;</span><br></pre></td></tr></table></figure></li><li><p>方案二：锚点定位 (适用连续ID)</p><p>如果ID是连续的且可以推断，直接用 Where 过滤。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tb_sku WHERE id &gt; 2000000 LIMIT 10;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="6-Count-优化"><a href="#6-Count-优化" class="headerlink" title="6. Count 优化"></a>6. Count 优化</h3><p><strong>核心目标:</strong> 了解不同 Count 写法的性能差异 (InnoDB 引擎)。</p><ul><li><strong>性能排序:</strong> <code>count(*) ≈ count(1) &gt; count(主键) &gt; count(字段)</code></li><li><strong>原理区别:</strong><ul><li><strong>count(字段):</strong> 会遍历全表，<strong>不计算 NULL 值</strong>。如果字段没有 <code>NOT NULL</code> 约束，还要一行行判断是否为 NULL，最慢。</li><li><strong>count(主键):</strong> 遍历全表，取出主键，累加。</li><li><strong>count(*):</strong> MySQL 做了专门优化，不取值，直接按行累加。InnoDB 会自动选择最小的二级索引进行遍历（成本最低）。</li></ul></li><li><strong>建议:</strong> 总是使用 <code>count(*)</code>。</li><li><strong>超大数据量:</strong> 如果需要频繁查询千万级数据的总数且允许微小误差，使用 <code>EXPLAIN</code> 的 <code>rows</code> 值估算；要求精确则需自己在 Redis 或计数表中维护计数。</li></ul><hr><h3 id="7-Update-优化"><a href="#7-Update-优化" class="headerlink" title="7. Update 优化"></a>7. Update 优化</h3><p><strong>核心目标:</strong> 避免<strong>行锁 (Row Lock)</strong> 升级为 <strong>表锁 (Table Lock)</strong>。</p><ul><li><p><strong>索引是关键:</strong> InnoDB 的行锁是加在<strong>索引</strong>上的，而不是加在记录上的。</p></li><li><p><strong>必须走索引:</strong></p><ul><li>如果 <code>UPDATE</code> 语句的 <code>WHERE</code> 条件字段<strong>建立了索引</strong>，InnoDB 会锁定对应的行（行锁），并发性能好。</li><li>如果 <code>WHERE</code> 条件字段<strong>没有索引</strong>（或索引失效），InnoDB 将被迫锁住整张表（表锁），导致其他事务无法操作该表，严重阻塞业务。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 假设 name 字段没有索引</span><br><span class="line">-- 这条语句会锁住整张表！</span><br><span class="line">UPDATE student SET name = &#x27;NewName&#x27; WHERE name = &#x27;OldName&#x27;;</span><br></pre></td></tr></table></figure></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MySQL]索引</title>
      <link href="/2026/01/15/MySQL-%E7%B4%A2%E5%BC%95/"/>
      <url>/2026/01/15/MySQL-%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-索引核心知识体系总结"><a href="#MySQL-索引核心知识体系总结" class="headerlink" title="MySQL 索引核心知识体系总结"></a>MySQL 索引核心知识体系总结</h1><h2 id="1-索引概述"><a href="#1-索引概述" class="headerlink" title="1. 索引概述"></a>1. 索引概述</h2><ul><li><strong>定义</strong>：索引（Index）是帮助 MySQL <strong>高效获取数据</strong>的数据结构（有序）。</li><li><strong>本质</strong>：空间换时间。</li><li><strong>优缺点</strong>：<ul><li><strong>优点</strong>：<ol><li>大大减少服务器扫描的数据量（降低 I&#x2F;O 成本）。</li><li>帮助服务器避免排序和临时表（降低 CPU 成本）。</li></ol></li><li><strong>缺点</strong>：<ol><li>占用磁盘空间。</li><li>降低写操作（<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>）的速度，因为需要维护索引结构。</li></ol></li></ul></li></ul><h2 id="2-索引结构-InnoDB"><a href="#2-索引结构-InnoDB" class="headerlink" title="2. 索引结构 (InnoDB)"></a>2. 索引结构 (InnoDB)</h2><p>MySQL 默认存储引擎 InnoDB 使用 <strong>B+ Tree</strong> 结构。</p><ul><li><strong>B+ Tree 特点</strong>：<ol><li><strong>非叶子节点</strong>仅存储键值（Key）和指针，不存储数据，增加了节点的度（Fan-out），树的高度通常控制在 3-4 层，减少 I&#x2F;O 次数。</li><li><strong>叶子节点</strong>存储所有数据（Key + Row Data 或 Key + PK），且叶子节点之间通过<strong>双向链表</strong>连接。</li><li><strong>扫库方便</strong>：支持范围查询，全表扫描只需遍历叶子节点链表。</li></ol></li><li><strong>为什么不用其他结构？</strong><ul><li><strong>Hash</strong>：仅支持精确匹配（<code>=</code>），不支持范围查询（<code>&gt;</code>, <code>&lt;</code>），不支持排序。</li><li><strong>二叉树&#x2F;红黑树</strong>：大数据量下树太高，磁盘 I&#x2F;O 次数过多；可能会退化成链表（二叉树）。</li><li><strong>B-Tree</strong>：非叶子节点也存数据，导致单页存储的 Key 变少，树的高度变高，I&#x2F;O 增加。</li></ul></li></ul><h2 id="3-索引分类"><a href="#3-索引分类" class="headerlink" title="3. 索引分类"></a>3. 索引分类</h2><h3 id="3-1-按物理存储分类-InnoDB-核心"><a href="#3-1-按物理存储分类-InnoDB-核心" class="headerlink" title="3.1 按物理存储分类 (InnoDB 核心)"></a>3.1 按物理存储分类 (InnoDB 核心)</h3><table><thead><tr><th><strong>分类</strong></th><th><strong>聚集索引 (Clustered Index)</strong></th><th><strong>二级索引 (Secondary Index)</strong></th></tr></thead><tbody><tr><td><strong>存储内容</strong></td><td>叶子节点存储<strong>完整行数据</strong></td><td>叶子节点存储<strong>索引列值 + 主键值</strong></td></tr><tr><td><strong>数量</strong></td><td>有且仅有一个</td><td>可以有多个</td></tr><tr><td><strong>选取规则</strong></td><td>1. 主键 (Primary Key) 2. 第一个唯一非空索引 (Unique Not Null) 3. 自动生成隐藏列 ROW_ID</td><td>除了聚集索引外的所有索引</td></tr><tr><td><strong>回表查询</strong></td><td>不需要</td><td>需要（先查二级索引拿到主键，再回聚集索引查数据），除非<strong>覆盖索引</strong></td></tr></tbody></table><h3 id="3-2-按逻辑-功能分类"><a href="#3-2-按逻辑-功能分类" class="headerlink" title="3.2 按逻辑&#x2F;功能分类"></a>3.2 按逻辑&#x2F;功能分类</h3><ul><li><strong>主键索引 (Primary)</strong>：唯一且非空。</li><li><strong>唯一索引 (Unique)</strong>：索引列值必须唯一，允许 NULL。</li><li><strong>普通索引 (Normal)</strong>：无特殊限制。</li><li><strong>全文索引 (Fulltext)</strong>：用于大文本搜索（通常用 ES 替代）。</li></ul><h3 id="3-3-按字段个数分类"><a href="#3-3-按字段个数分类" class="headerlink" title="3.3 按字段个数分类"></a>3.3 按字段个数分类</h3><ul><li><strong>单列索引</strong>：一个索引包含一个列。</li><li><strong>联合索引</strong>：一个索引包含多个列（涉及最左前缀原则）。</li></ul><h2 id="4-索引相关语法"><a href="#4-索引相关语法" class="headerlink" title="4. 索引相关语法"></a>4. 索引相关语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 创建索引</span><br><span class="line">CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (col_name [ASC|DESC], ...);</span><br><span class="line"></span><br><span class="line">-- 查看索引</span><br><span class="line">SHOW INDEX FROM table_name;</span><br><span class="line"></span><br><span class="line">-- 删除索引</span><br><span class="line">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure><h2 id="5-SQL-性能分析工具"><a href="#5-SQL-性能分析工具" class="headerlink" title="5. SQL 性能分析工具"></a>5. SQL 性能分析工具</h2><h3 id="5-1-SQL-执行频率"><a href="#5-1-SQL-执行频率" class="headerlink" title="5.1 SQL 执行频率"></a>5.1 SQL 执行频率</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GLOBAL STATUS LIKE &#x27;Com_______&#x27;;</span><br></pre></td></tr></table></figure><ul><li>查看 <code>Com_select</code>, <code>Com_insert</code>, <code>Com_update</code>, <code>Com_delete</code> 的数值，判断系统是读多写少还是写多读少，决定优化方向。</li></ul><h3 id="5-2-慢查询日志-Slow-Query-Log"><a href="#5-2-慢查询日志-Slow-Query-Log" class="headerlink" title="5.2 慢查询日志 (Slow Query Log)"></a>5.2 慢查询日志 (Slow Query Log)</h3><ul><li><strong>作用</strong>：记录执行时间超过 <code>long_query_time</code>（默认 10s）的 SQL。</li><li><strong>配置</strong>：<code>/etc/my.cnf</code> 中设置 <code>slow_query_log=1</code> 和 <code>long_query_time=2</code> (示例)。</li><li><strong>分析</strong>：定位出拖慢系统的具体 SQL 语句。</li></ul><h3 id="5-3-Profile-详情"><a href="#5-3-Profile-详情" class="headerlink" title="5.3 Profile 详情"></a>5.3 Profile 详情</h3><ul><li><strong>作用</strong>：查看 SQL 执行在每一个阶段（CPU、IO、Context Switch）的耗时。</li><li><strong>命令</strong>：<ul><li><code>SET profiling = 1;</code> (开启)</li><li><code>SHOW PROFILES;</code> (查看最近 SQL 列表)</li><li><code>SHOW PROFILE FOR QUERY query_id;</code> (查看具体资源消耗)</li></ul></li></ul><h3 id="5-4-EXPLAIN-执行计划-核心"><a href="#5-4-EXPLAIN-执行计划-核心" class="headerlink" title="5.4 EXPLAIN 执行计划 (核心)"></a>5.4 EXPLAIN 执行计划 (核心)</h3><p>使用 <code>EXPLAIN SELECT ...</code> 分析查询。关注核心字段：</p><ol><li><strong>type (访问类型)</strong>：性能由好到差排序：<ul><li><code>NULL</code> (不查表)</li><li><code>system</code> (系统表 1 行)</li><li><code>const</code> (主键&#x2F;唯一索引等值查询)</li><li><code>eq_ref</code> (主键&#x2F;唯一索引关联)</li><li><code>ref</code> (非唯一索引等值查询)</li><li><code>range</code> (索引范围查询)</li><li><code>index</code> (全索引扫描)</li><li><code>all</code> (全表扫描)</li><li><strong>目标</strong>：至少达到 <code>range</code>，最好是 <code>ref</code>。</li></ul></li><li><strong>possible_keys</strong>：可能用到的索引。</li><li><strong>key</strong>：实际用到的索引。</li><li><strong>key_len</strong>：索引使用的字节数（越短越好，用于检查联合索引是否完全生效）。</li><li><strong>Extra</strong>：<ul><li><code>Using index</code>：<strong>好</strong>。使用了覆盖索引，无需回表。</li><li><code>Using where</code>：需要过滤。</li><li><code>Using temporary</code>：<strong>差</strong>。使用了临时表（常见于 group by）。</li><li><code>Using filesort</code>：<strong>差</strong>。需要文件排序（常见于 order by 未命中索引）。</li></ul></li></ol><h2 id="6-索引的使用与失效场景"><a href="#6-索引的使用与失效场景" class="headerlink" title="6. 索引的使用与失效场景"></a>6. 索引的使用与失效场景</h2><h3 id="6-1-最左前缀法则-联合索引"><a href="#6-1-最左前缀法则-联合索引" class="headerlink" title="6.1 最左前缀法则 (联合索引)"></a>6.1 最左前缀法则 (联合索引)</h3><ul><li>查询从索引的<strong>最左列</strong>开始，<strong>不能跳过</strong>索引中的列。</li><li>如果跳过某一列，后面的列索引失效。</li><li><strong>范围查询右侧失效</strong>：如果遇到范围查询 (<code>&gt;</code>, <code>&lt;</code>)，则<strong>该列之后</strong>的列索引失效。（<code>&gt;=</code>、<code>&lt;=</code> 通常不会失效）。</li></ul><h3 id="6-2-常见索引失效情况"><a href="#6-2-常见索引失效情况" class="headerlink" title="6.2 常见索引失效情况"></a>6.2 常见索引失效情况</h3><ol><li><strong>函数运算</strong>：<code>WHERE substring(name, 1, 2) = &#39;ab&#39;</code>（对索引列做运算）。</li><li><strong>字符串不加引号</strong>：<code>WHERE phone = 123</code>（发生隐式类型转换）。</li><li><strong>模糊查询</strong>：<code>LIKE &#39;%abc&#39;</code>（头部模糊匹配失效，<code>&#39;abc%&#39;</code> 走索引）。</li><li><strong>OR 连接</strong>：<code>OR</code> 两侧只要有一侧没有索引，涉及的索引全部失效。</li><li><strong>数据分布影响</strong>：如果 MySQL 评估全表扫描比走索引快（例如表中绝大多数数据都符合条件），则放弃索引。</li></ol><h3 id="6-3-覆盖索引-Covering-Index"><a href="#6-3-覆盖索引-Covering-Index" class="headerlink" title="6.3 覆盖索引 (Covering Index)"></a>6.3 覆盖索引 (Covering Index)</h3><ul><li><strong>定义</strong>：查询的列 (<code>SELECT</code> 后的列) 刚好都在索引中，不需要回表查询。</li><li><strong>建议</strong>：尽量避免 <code>SELECT *</code>，指定必要列，争取命中覆盖索引（Extra: <code>Using index</code>）。</li></ul><h3 id="6-4-前缀索引"><a href="#6-4-前缀索引" class="headerlink" title="6.4 前缀索引"></a>6.4 前缀索引</h3><ul><li>针对 <code>VARCHAR</code>, <code>TEXT</code> 等长字符串，只对前 N 个字符建立索引，以节省空间。</li><li>语法：<code>CREATE INDEX idx_name ON table(column(n));</code></li></ul><h2 id="7-索引的设计原则"><a href="#7-索引的设计原则" class="headerlink" title="7. 索引的设计原则"></a>7. 索引的设计原则</h2><ol><li><p><strong>针对性</strong>：对查询频次高、数据量大（&gt;100万行）的表建立索引。</p></li><li><p><strong>字段选择</strong>：</p><ul><li><code>WHERE</code> 子句中的过滤条件字段。</li><li><code>ORDER BY</code>、<code>GROUP BY</code> 涉及的字段。</li></ul></li><li><p><strong>区分度</strong>：选择区分度高（唯一性高）的列（如 UUID、手机号）。区分度低的列（如性别、状态）不适合建单列索引。</p></li><li><p><strong>联合索引优先</strong>：尽量使用联合索引，利用覆盖索引机制，减少回表。</p></li><li><p><strong>字符串优化</strong>：长字符串使用前缀索引。</p></li><li><p><strong>控制数量</strong>：索引不是越多越好，过多的索引会拖慢写性能并增加优化器负担。</p></li><li><p><strong>非空约束</strong>：尽量将字段设为 <code>NOT NULL</code>，有利于优化器确定索引效率。</p><h2 id="8-SQL-提示-SQL-Hints"><a href="#8-SQL-提示-SQL-Hints" class="headerlink" title="8. SQL 提示 (SQL Hints)"></a>8. SQL 提示 (SQL Hints)</h2><h3 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h3><ul><li><strong>定义</strong>：开发者在 SQL 语句中显式地添加指令，人为干预数据库优化器（Optimizer）对索引的选择。</li><li><strong>场景</strong>：当 MySQL 优化器生成的执行计划不是最优解（例如选错了索引，或者放弃索引走全表扫描）时使用。</li></ul><h3 id="8-2-常用语法"><a href="#8-2-常用语法" class="headerlink" title="8.2 常用语法"></a>8.2 常用语法</h3><p>SQL 提示需紧跟在表名之后。</p><h4 id="1-USE-INDEX-建议"><a href="#1-USE-INDEX-建议" class="headerlink" title="1. USE INDEX (建议)"></a>1. USE INDEX (建议)</h4><ul><li><p><strong>含义</strong>：<strong>建议</strong> MySQL 使用指定的索引之一。</p></li><li><p><strong>特点</strong>：这只是一个参考，优化器评估后如果觉得全表扫描更快，<strong>依然可能忽略</strong>该提示。</p></li><li><p><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name USE INDEX (idx_name) WHERE col = &#x27;value&#x27;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-IGNORE-INDEX-忽略"><a href="#2-IGNORE-INDEX-忽略" class="headerlink" title="2. IGNORE INDEX (忽略)"></a>2. IGNORE INDEX (忽略)</h4><ul><li><p><strong>含义</strong>：<strong>禁止</strong> MySQL 使用指定的索引。</p></li><li><p><strong>场景</strong>：</p><ul><li>用于验证某个索引是否对查询产生负面影响。</li></ul></li></ul></li></ol><ul><li><p>当你确定全表扫描比走该索引更快时（例如数据分布极不均匀）。</p></li><li><p><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name IGNORE INDEX (idx_name) WHERE col = &#x27;value&#x27;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-FORCE-INDEX-强制"><a href="#3-FORCE-INDEX-强制" class="headerlink" title="3. FORCE INDEX (强制)"></a>3. FORCE INDEX (强制)</h4><ul><li><p><strong>含义</strong>：<strong>强制</strong> MySQL 使用指定的索引。</p></li><li><p><strong>特点</strong>：比 <code>USE INDEX</code> 语气更重。如果强制的索引无法使用，MySQL 通常会选择全表扫描作为代价，极少会忽略该指令。</p></li><li><p><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name FORCE INDEX (idx_name) WHERE col = &#x27;value&#x27;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MySQL]基础操作</title>
      <link href="/2026/01/15/MySQL-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
      <url>/2026/01/15/MySQL-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="DDL基本操作"><a href="#DDL基本操作" class="headerlink" title="DDL基本操作"></a>DDL基本操作</h1><h2 id="1-数据库操作"><a href="#1-数据库操作" class="headerlink" title="1.数据库操作"></a>1.数据库操作</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p><strong>查询所有数据库</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure><p><strong>查询当前的数据库</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATABASE();</span><br></pre></td></tr></table></figure><p><strong>创建数据库</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排列顺序];</span><br></pre></td></tr></table></figure><p><em>注：[ ]内可不写</em></p><p><strong>删除数据库</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE [IF EXISTS] 数据库名;</span><br></pre></td></tr></table></figure><p><strong>使用数据库</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure><p><strong>查询当前数据库中所有的表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure><p><strong>查询表结构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC 表名;</span><br></pre></td></tr></table></figure><p><strong>查询指定表的建表语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE TABLE 表名;</span><br></pre></td></tr></table></figure><p>###创建<br><strong>创建表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">字段1 字段1类型[COMMENT 字段1注释],</span><br><span class="line">字段1 字段1类型[COMMENT 字段1注释],</span><br><span class="line">字段1 字段1类型[COMMENT 字段1注释],</span><br><span class="line">......</span><br><span class="line">字段1 字段1类型[COMMENT 字段1注释]</span><br><span class="line">)[COMMENT 表注释]</span><br></pre></td></tr></table></figure><p><em>注：[…]内为可选项   最后一个字段后没有逗号<br>在MySQL中字符串数据类型varchar(…)为变长字符串括号内为字符最大容量</em></p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table tb_test1(</span><br><span class="line">    id int comment&#x27;编号&#x27;,</span><br><span class="line">    name varchar(50) comment &#x27;姓名&#x27;,</span><br><span class="line">    age int comment &#x27;年龄&#x27;,</span><br><span class="line">    gender varchar(1) comment &#x27;性别&#x27;</span><br><span class="line">    ) comment &#x27;测试表01&#x27;;</span><br></pre></td></tr></table></figure><p><strong>经过<code>DESC 表名;</code>语句的显示效果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field  | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| id     | int         | YES  |     | NULL    |       |</span><br><span class="line">| name   | varchar(50) | YES  |     | NULL    |       |</span><br><span class="line">| age    | int         | YES  |     | NULL    |       |</span><br><span class="line">| gender | varchar(1)  | YES  |     | NULL    |       |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br></pre></td></tr></table></figure><p><strong>经过<code>SHOW CREATE TABLE 表名;</code>语句的显示效果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Table    | Create Table                                                                                                                                                                                                                                                                                         |</span><br><span class="line">+----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| tb_test1 | CREATE TABLE `tb_test1` (</span><br><span class="line">  `id` int DEFAULT NULL COMMENT &#x27;编号&#x27;,</span><br><span class="line">  `name` varchar(50) DEFAULT NULL COMMENT &#x27;姓名&#x27;,</span><br><span class="line">  `age` int DEFAULT NULL COMMENT &#x27;年龄&#x27;,</span><br><span class="line">  `gender` varchar(1) DEFAULT NULL COMMENT &#x27;性别&#x27;</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=&#x27;测试表01&#x27; |</span><br><span class="line">+----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p><strong>添加字段</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];</span><br></pre></td></tr></table></figure><p><strong>修改原有字段数据类型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);</span><br></pre></td></tr></table></figure><p><strong>查询表结构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</span><br></pre></td></tr></table></figure><p><strong>删除字段</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP 字段名;</span><br></pre></td></tr></table></figure><p><strong>修改表名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 RENAME TO 新表名;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><strong>删除表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE [IF EXISTS] 表名;</span><br></pre></td></tr></table></figure><p><strong>删除指定表，并重新创建该表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE 表名;</span><br></pre></td></tr></table></figure><h3 id="1-数值类型-Numeric-Types"><a href="#1-数值类型-Numeric-Types" class="headerlink" title="1. 数值类型 (Numeric Types)"></a>1. 数值类型 (Numeric Types)</h3><p>这里有一个重点：<strong>Java 的 <code>long</code> 对应 MySQL 的 <code>BIGINT</code></strong>，<strong>钱（货币）一定要用 <code>DECIMAL</code></strong>。</p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>大小 (存储空间)</strong></th><th><strong>描述与应用场景</strong></th><th><strong>对应 Java 类型</strong></th></tr></thead><tbody><tr><td><code>TINYINT</code></td><td>1 byte</td><td>非常小的整数。常用 <code>TINYINT(1)</code> 来表示 <strong>布尔值 (Boolean)</strong> (0为假, 1为真)。</td><td><code>Byte</code> &#x2F; <code>Boolean</code></td></tr><tr><td><code>SMALLINT</code></td><td>2 bytes</td><td>小整数。范围约 $\pm 3$ 万。</td><td><code>Short</code></td></tr><tr><td><code>MEDIUMINT</code></td><td>3 bytes</td><td>中等大小整数。范围约 $\pm 800$ 万 (很少用)。</td><td><code>Integer</code></td></tr><tr><td><code>INT</code> &#x2F; <code>INTEGER</code></td><td>4 bytes</td><td><strong>最常用的整数</strong>。范围约 $\pm 21$ 亿。</td><td><code>Integer</code></td></tr><tr><td><code>BIGINT</code></td><td>8 bytes</td><td>极大整数。通常用于 <strong>主键 ID</strong> 或像推特点击量这种大数。</td><td><code>Long</code></td></tr><tr><td><code>FLOAT</code></td><td>4 bytes</td><td>单精度浮点数。<strong>不精确</strong>，存在精度丢失问题。</td><td><code>Float</code></td></tr><tr><td><code>DOUBLE</code></td><td>8 bytes</td><td>双精度浮点数。精度比 Float 高，但仍 <strong>不精确</strong>。</td><td><code>Double</code></td></tr><tr><td><code>DECIMAL(M, D)</code></td><td>变长 (取决于M)</td><td><strong>定点数</strong> (精确值)。M是总位数，D是小数位。<strong>涉及金额&#x2F;财务必用此类型</strong>。</td><td><code>BigDecimal</code></td></tr></tbody></table><hr><h3 id="2-字符串与二进制类型-String-Binary-Types"><a href="#2-字符串与二进制类型-String-Binary-Types" class="headerlink" title="2. 字符串与二进制类型 (String &amp; Binary Types)"></a>2. 字符串与二进制类型 (String &amp; Binary Types)</h3><p>重点区分：<strong><code>CHAR</code> 是定长（死板），<code>VARCHAR</code> 是变长（灵活）。</strong></p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>大小 (存储空间)</strong></th><th><strong>描述与应用场景</strong></th><th><strong>对应 Java 类型</strong></th></tr></thead><tbody><tr><td><code>CHAR(M)</code></td><td>M bytes (0-255)</td><td><strong>定长字符串</strong>。如果你存 “A”，它也会占满 M 个空间。适合存固定长度数据 (如身份证、手机号、性别)。速度快但费空间。</td><td><code>String</code></td></tr><tr><td><code>VARCHAR(M)</code></td><td>变长 (0-65535)</td><td><strong>变长字符串</strong>。存多少占多少+长度标识位。<strong>开发中最常用的字符串类型</strong> (如用户名、地址)。</td><td><code>String</code></td></tr><tr><td><code>TINYTEXT</code></td><td>0-255 bytes</td><td>短文本。</td><td><code>String</code></td></tr><tr><td><code>TEXT</code></td><td>0-64 KB</td><td>长文本。适合存文章内容、评论、简介。</td><td><code>String</code></td></tr><tr><td><code>MEDIUMTEXT</code></td><td>0-16 MB</td><td>中长文本。适合存书的内容。</td><td><code>String</code></td></tr><tr><td><code>LONGTEXT</code></td><td>0-4 GB</td><td>极长文本。甚至可以把一整本百科全书存进去。</td><td><code>String</code></td></tr><tr><td><code>BLOB</code> 系列</td><td>变长</td><td>二进制大对象。用于存图片、音频等 (通常<strong>不建议</strong>直接存数据库，建议存文件路径)。</td><td><code>byte[]</code></td></tr><tr><td><code>JSON</code></td><td>变长</td><td><strong>JSON 文档</strong>。MySQL 5.7+ 支持。适合存非结构化数据，能直接解析 Key-Value。</td><td><code>String</code> &#x2F; Object</td></tr></tbody></table><hr><h3 id="3-日期与时间类型-Date-Time-Types"><a href="#3-日期与时间类型-Date-Time-Types" class="headerlink" title="3. 日期与时间类型 (Date &amp; Time Types)"></a>3. 日期与时间类型 (Date &amp; Time Types)</h3><p>重点区分：<strong><code>TIMESTAMP</code> 会随时区变化，<code>DATETIME</code> 不会。</strong></p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>大小 (存储空间)</strong></th><th><strong>描述与应用场景</strong></th><th><strong>对应 Java 类型</strong></th></tr></thead><tbody><tr><td><code>DATE</code></td><td>3 bytes</td><td>仅日期。格式：<code>YYYY-MM-DD</code>。如：生日 <code>1990-01-01</code>。</td><td><code>java.sql.Date</code> &#x2F; <code>LocalDate</code></td></tr><tr><td><code>TIME</code></td><td>3 bytes</td><td>仅时间。格式：<code>HH:MM:SS</code>。如：时长 <code>12:30:00</code>。</td><td><code>java.sql.Time</code> &#x2F; <code>LocalTime</code></td></tr><tr><td><code>YEAR</code></td><td>1 byte</td><td>年份。格式：<code>YYYY</code> (1901-2155)。</td><td><code>Integer</code> &#x2F; <code>Year</code></td></tr><tr><td><code>DATETIME</code></td><td>8 bytes</td><td><strong>日期+时间</strong>。范围：1000年到9999年。<strong>绝对时间</strong>，存进去是什么，取出来就是什么，不理会时区。</td><td><code>LocalDateTime</code></td></tr><tr><td><code>TIMESTAMP</code></td><td>4 bytes</td><td><strong>时间戳</strong>。范围：1970年到2038年。<strong>涉及时区转换</strong> (存进去会转成UTC，取出来转回当前时区)。适合记录“创建时间&#x2F;修改时间”。</td><td><code>Timestamp</code> &#x2F; <code>Instant</code></td></tr></tbody></table><hr><h1 id="DML基础操作"><a href="#DML基础操作" class="headerlink" title="DML基础操作"></a>DML基础操作</h1><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p><strong>给指定字段添加数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 (字段名1,字段名2,字段名3,...) VALUES (值1,值2,值3,...);</span><br></pre></td></tr></table></figure><p><strong>给全部字段添加数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 VALUES (值1,值2,值3,...);</span><br></pre></td></tr></table></figure><p><strong>批量添加数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 (字段名1,字段名2,字段名3,...) VALUES (值1,值2,值3,...),(值1,值2,值3,...),...;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 VALUES (值1,值2,值3,...),(值1,值2,值3,...),(值1,值2,值3,...),...;</span><br></pre></td></tr></table></figure><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM 表名 WHERE 条件</span><br></pre></td></tr></table></figure><p><em>注：</em></p><p><em>1.若不写where语句则是删除整张表的所有数据</em></p><p><em>2.delete不能删除某一个字段的值 可以用updata设置成null</em></p><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATA 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... WHERE 条件;</span><br></pre></td></tr></table></figure><p><em>注：要是不写where语句则是修改整张表的字段的值</em></p><hr><h1 id="DQL基本操作"><a href="#DQL基本操作" class="headerlink" title="DQL基本操作"></a>DQL基本操作</h1><h3 id="1-基本查询"><a href="#1-基本查询" class="headerlink" title="1.基本查询"></a>1.基本查询</h3><p><strong>查询多个字段</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段1 AS &#x27;别名&#x27;,字段2 &#x27;别名&#x27;,字段3,...FROM 表名;</span><br><span class="line">-- 别名可以不写 如若想写别名显示 可以写AS也可不写</span><br></pre></td></tr></table></figure><p><strong>去除重复记录</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT 字段列表 FROM 表名;</span><br></pre></td></tr></table></figure><h3 id="2-条件查询"><a href="#2-条件查询" class="headerlink" title="2.条件查询"></a>2.条件查询</h3><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 WHERE 条件列表;</span><br></pre></td></tr></table></figure><p><strong>条件</strong></p><table><thead><tr><th align="center">比较运算符</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&gt;&#x3D;</td><td align="center">大于等于</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&lt;&#x3D;</td><td align="center">小于等于</td></tr><tr><td align="center">&#x3D;</td><td align="center">等于</td></tr><tr><td align="center">&lt;&gt; 或 !&#x3D;</td><td align="center">不等于</td></tr><tr><td align="center">BETWEEN 最小值 AND 最大值</td><td align="center">在某个范围之内(含最大最小值)</td></tr><tr><td align="center">IN(…)</td><td align="center">至少符合IN列表中一项的数据</td></tr><tr><td align="center">LIKE 占位符</td><td align="center">模糊匹配：’_’  : 任意一个字符  ‘%’ : 任意个字符</td></tr><tr><td align="center">IS NULL</td><td align="center">是NULL</td></tr></tbody></table><hr><table><thead><tr><th align="center">逻辑运算符</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">AND 或 &amp;&amp;</td><td align="center">与</td></tr><tr><td align="center">OR 或 ||</td><td align="center">或</td></tr><tr><td align="center">NOT 或！</td><td align="center">非</td></tr></tbody></table><h3 id="3-聚合函数"><a href="#3-聚合函数" class="headerlink" title="3.聚合函数"></a>3.聚合函数</h3><p><code>将一列数据作为一个整体 进行纵向计算</code></p><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">count</td><td align="center">统计数量</td></tr><tr><td align="center">max</td><td align="center">最大值</td></tr><tr><td align="center">min</td><td align="center">最小值</td></tr><tr><td align="center">avg</td><td align="center">平均值</td></tr><tr><td align="center">sum</td><td align="center">求和</td></tr></tbody></table><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 聚合函数(字符列表) FROM 表名;</span><br></pre></td></tr></table></figure><p><em>注：null值不参与聚合函数的运算！</em></p><h3 id="4-分组查询"><a href="#4-分组查询" class="headerlink" title="4.分组查询"></a>4.分组查询</h3><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后的过滤条件];</span><br></pre></td></tr></table></figure><p><strong>WHERE与HAVING的区别</strong></p><p>where是在分组之前进行的过滤 满足where条件的才可进行分组</p><p>having是分组之后进行的过滤</p><p><strong>执行顺序</strong></p><p><code>where &gt; 聚合函数 &gt; having</code></p><h3 id="5-排序查询"><a href="#5-排序查询" class="headerlink" title="5.排序查询"></a>5.排序查询</h3><p><strong>1.语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2...;</span><br></pre></td></tr></table></figure><p><strong>2.排序方式</strong></p><p>1.升序：ASC（默认值）</p><p>2.降序：DESC</p><h3 id="6-分页查询"><a href="#6-分页查询" class="headerlink" title="6.分页查询"></a>6.分页查询</h3><p><strong>1.语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询录数;</span><br></pre></td></tr></table></figure><p><strong>2.示例</strong></p><p>若查询的数据每一页有十个数据，那么我查询第一页的代码是</p><p><code>SELECT 字段列表 FROM 表名 LIMIT 0, 10;</code></p><p>如果是第一页则<code>起始索引</code>可以省略：</p><p><code>SELECT 字段列表 FROM 表名 LIMIT 10;</code></p><p>查询第二页的代码为：</p><p><code>SELECT 字段列表 FROM 表名 LIMIT 10, 10;</code></p><p>查询第n页的<code>起始索引</code>可以通过<code>（页数 - 1）* 查询录数</code>计算得出</p><p><em>注：索引是从0开始的！</em></p><h3 id="7-DQL的编写顺序"><a href="#7-DQL的编写顺序" class="headerlink" title="7.DQL的编写顺序"></a>7.DQL的编写顺序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">FROM</span><br><span class="line">WHERE</span><br><span class="line">GROUP BY</span><br><span class="line">HAVING</span><br><span class="line">ORDER BY</span><br><span class="line">LIMIT</span><br></pre></td></tr></table></figure><h3 id="8-DQL的执行顺序"><a href="#8-DQL的执行顺序" class="headerlink" title="8.DQL的执行顺序"></a>8.DQL的执行顺序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM</span><br><span class="line">WHERE</span><br><span class="line">GROUP BY</span><br><span class="line">HAVING</span><br><span class="line">SELECT</span><br><span class="line">ORDER BY</span><br><span class="line">LIMIT</span><br></pre></td></tr></table></figure><hr><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h3 id="1-字符串函数"><a href="#1-字符串函数" class="headerlink" title="1.字符串函数"></a>1.字符串函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-- 字符串拼接</span><br><span class="line">select concat(&#x27;1&#x27;,&#x27;23&#x27;); -- 123</span><br><span class="line"></span><br><span class="line">-- 转换为小写</span><br><span class="line">select lower(&#x27;Hello!&#x27;); -- hello!</span><br><span class="line"></span><br><span class="line">-- 转换为大写</span><br><span class="line">select upper(&#x27;Hello!&#x27;); -- HELLO!</span><br><span class="line"></span><br><span class="line">-- 左填充</span><br><span class="line">select lpad(&#x27;1&#x27;,5,&#x27;0&#x27;); -- 00001</span><br><span class="line"></span><br><span class="line">-- 右填充</span><br><span class="line">select rpad(&#x27;1&#x27;,5,&#x27;0&#x27;); -- 10000</span><br><span class="line"></span><br><span class="line">-- 去掉字符串头和尾的空格</span><br><span class="line">select trim(&#x27; 1 2 3 &#x27;); -- 123</span><br><span class="line"></span><br><span class="line">-- 截取字符串</span><br><span class="line">select substr(&#x27;123456&#x27;,1,3); -- 123</span><br></pre></td></tr></table></figure><h3 id="2-数值函数"><a href="#2-数值函数" class="headerlink" title="2.数值函数"></a>2.数值函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- 向上取整</span><br><span class="line">select ceil(1.1); -- 2</span><br><span class="line"></span><br><span class="line">-- 向下取整</span><br><span class="line">select floor(1.9); -- 1</span><br><span class="line"></span><br><span class="line">-- x/y的模</span><br><span class="line">select mod(7,3); -- 1</span><br><span class="line"></span><br><span class="line">-- 返回0~1内的随机数</span><br><span class="line">select rand(); -- 0.05256707784958843</span><br><span class="line"></span><br><span class="line">-- 把x四舍五入，保留y位小数</span><br><span class="line">select round(1.578, 2); -- 1.58</span><br></pre></td></tr></table></figure><h3 id="3-日期函数"><a href="#3-日期函数" class="headerlink" title="3.日期函数"></a>3.日期函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-- 返回当前日期</span><br><span class="line">select curdate(); -- 2026-01-13</span><br><span class="line"></span><br><span class="line">-- 返回当前时间</span><br><span class="line">select curtime(); -- 16:23:15</span><br><span class="line"></span><br><span class="line">-- 返回当前日期和时间</span><br><span class="line">select now(); -- 2026-01-13 16:24:00</span><br><span class="line"></span><br><span class="line">-- 获取传入date的年份</span><br><span class="line">select year(now()); -- 2026</span><br><span class="line"></span><br><span class="line">-- 获取传入date的月份</span><br><span class="line">select month(now()); -- 1</span><br><span class="line"></span><br><span class="line">-- 获取传入date的日份</span><br><span class="line">select day(now()); -- 13</span><br><span class="line"></span><br><span class="line">-- 返回传入的日期加上传入的时间间隔之后的时间值 INTERVAL是固定值</span><br><span class="line">select date_add(now(), INTERVAL 30 year); -- 2056-01-13 16:26:51</span><br><span class="line"></span><br><span class="line">-- 返回两个时间之间的间隔</span><br><span class="line">select datediff(now(), &#x27;2007-6-4&#x27;); -- 6798</span><br></pre></td></tr></table></figure><h3 id="4-流程函数"><a href="#4-流程函数" class="headerlink" title="4.流程函数"></a>4.流程函数</h3><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">if(value, t, f)</td><td align="center">如果value为true，返回t，否则返回f</td></tr><tr><td align="center">ifnull(value 1, value 2)</td><td align="center">如果value 1不为空则返回value 1，否则返回value 2</td></tr><tr><td align="center">case when [val1] then [res1]…else[default] end</td><td align="center">如果val1为true,返回res1,…否则返回default默认值</td></tr><tr><td align="center">case [expr] when [val1] then [res1]…else[def] end</td><td align="center">如果expr的值等于val1,返回res1,…否则返回def</td></tr></tbody></table><hr><h1 id="多表查询例题"><a href="#多表查询例题" class="headerlink" title="多表查询例题"></a>多表查询例题</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">-- ------------------------------------&gt; 多表查询 &lt;--------------------------------------------</span><br><span class="line">-- 准备数据</span><br><span class="line">create table dept(</span><br><span class="line">                     id   int auto_increment comment &#x27;ID&#x27; primary key,</span><br><span class="line">                     name varchar(50) not null comment &#x27;部门名称&#x27;</span><br><span class="line">)comment &#x27;部门表&#x27;;</span><br><span class="line"></span><br><span class="line">create table emp(</span><br><span class="line">                    id  int auto_increment comment &#x27;ID&#x27; primary key,</span><br><span class="line">                    name varchar(50) not null comment &#x27;姓名&#x27;,</span><br><span class="line">                    age  int comment &#x27;年龄&#x27;,</span><br><span class="line">                    job varchar(20) comment &#x27;职位&#x27;,</span><br><span class="line">                    salary int comment &#x27;薪资&#x27;,</span><br><span class="line">                    entrydate date comment &#x27;入职时间&#x27;,</span><br><span class="line">                    managerid int comment &#x27;直属领导ID&#x27;,</span><br><span class="line">                    dept_id int comment &#x27;部门ID&#x27;</span><br><span class="line">)comment &#x27;员工表&#x27;;</span><br><span class="line"></span><br><span class="line">-- 添加外键</span><br><span class="line">alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id);</span><br><span class="line"></span><br><span class="line">INSERT INTO dept (id, name) VALUES (1, &#x27;研发部&#x27;), (2, &#x27;市场部&#x27;),(3, &#x27;财务部&#x27;), (4, &#x27;销售部&#x27;), (5, &#x27;总经办&#x27;), (6, &#x27;人事部&#x27;);</span><br><span class="line">INSERT INTO emp (id, name, age, job,salary, entrydate, managerid, dept_id) VALUES</span><br><span class="line">                                                                               (1, &#x27;金庸&#x27;, 66, &#x27;总裁&#x27;,20000, &#x27;2000-01-01&#x27;, null,5),</span><br><span class="line"></span><br><span class="line">                                                                               (2, &#x27;张无忌&#x27;, 20, &#x27;项目经理&#x27;,12500, &#x27;2005-12-05&#x27;, 1,1),</span><br><span class="line">                                                                               (3, &#x27;杨逍&#x27;, 33, &#x27;开发&#x27;, 8400,&#x27;2000-11-03&#x27;, 2,1),</span><br><span class="line">                                                                               (4, &#x27;韦一笑&#x27;, 48, &#x27;开发&#x27;,11000, &#x27;2002-02-05&#x27;, 2,1),</span><br><span class="line">                                                                               (5, &#x27;常遇春&#x27;, 43, &#x27;开发&#x27;,10500, &#x27;2004-09-07&#x27;, 3,1),</span><br><span class="line">                                                                               (6, &#x27;小昭&#x27;, 19, &#x27;程序员鼓励师&#x27;,6600, &#x27;2004-10-12&#x27;, 2,1),</span><br><span class="line"></span><br><span class="line">                                                                               (7, &#x27;灭绝&#x27;, 60, &#x27;财务总监&#x27;,8500, &#x27;2002-09-12&#x27;, 1,3),</span><br><span class="line">                                                                               (8, &#x27;周芷若&#x27;, 19, &#x27;会计&#x27;,48000, &#x27;2006-06-02&#x27;, 7,3),</span><br><span class="line">                                                                               (9, &#x27;丁敏君&#x27;, 23, &#x27;出纳&#x27;,5250, &#x27;2009-05-13&#x27;, 7,3),</span><br><span class="line"></span><br><span class="line">                                                                               (10, &#x27;赵敏&#x27;, 20, &#x27;市场部总监&#x27;,12500, &#x27;2004-10-12&#x27;, 1,2),</span><br><span class="line">                                                                               (11, &#x27;鹿杖客&#x27;, 56, &#x27;职员&#x27;,3750, &#x27;2006-10-03&#x27;, 10,2),</span><br><span class="line">                                                                               (12, &#x27;鹤笔翁&#x27;, 19, &#x27;职员&#x27;,3750, &#x27;2007-05-09&#x27;, 10,2),</span><br><span class="line">                                                                               (13, &#x27;方东白&#x27;, 19, &#x27;职员&#x27;,5500, &#x27;2009-02-12&#x27;, 10,2),</span><br><span class="line"></span><br><span class="line">                                                                               (14, &#x27;张三丰&#x27;, 88, &#x27;销售总监&#x27;,14000, &#x27;2004-10-12&#x27;, 1,4),</span><br><span class="line">                                                                               (15, &#x27;俞莲舟&#x27;, 38, &#x27;销售&#x27;,4600, &#x27;2004-10-12&#x27;, 14,4),</span><br><span class="line">                                                                               (16, &#x27;宋远桥&#x27;, 40, &#x27;销售&#x27;,4600, &#x27;2004-10-12&#x27;, 14,4),</span><br><span class="line">                                                                               (17, &#x27;陈友谅&#x27;, 42, null,2000, &#x27;2011-10-12&#x27;, 1,null);</span><br><span class="line">-- ---------------------------------------&gt; 多表查询案例 &lt;----------------------------------</span><br><span class="line">create table salgrade(</span><br><span class="line">                         grade int,</span><br><span class="line">                         losal int,</span><br><span class="line">                         hisal int</span><br><span class="line">) comment &#x27;薪资等级表&#x27;;</span><br><span class="line"></span><br><span class="line">insert into salgrade values (1,0,3000);</span><br><span class="line">insert into salgrade values (2,3001,5000);</span><br><span class="line">insert into salgrade values (3,5001,8000);</span><br><span class="line">insert into salgrade values (4,8001,10000);</span><br><span class="line">insert into salgrade values (5,10001,15000);</span><br><span class="line">insert into salgrade values (6,15001,20000);</span><br><span class="line">insert into salgrade values (7,20001,25000);</span><br><span class="line">insert into salgrade values (8,25001,30000);</span><br><span class="line"></span><br><span class="line">-- 1. 查询员工的姓名、年龄、职位、部门信息 （隐式内连接）</span><br><span class="line">select e.name,e.age,e.job,d.name from emp e left join dept d on e.dept_id = d.id;</span><br><span class="line"></span><br><span class="line">select e.name,e.age,e.job,d.name from emp e , dept d where e.dept_id = d.id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 2. 查询年龄小于30岁的员工的姓名、年龄、职位、部门信息（显式内连接）</span><br><span class="line">select e.name,e.age,e.job,d.name from (select * from emp where emp.age &lt; 30) e left join dept d on e.dept_id = d.id;</span><br><span class="line">select e.name,e.age,e.job,d.name from emp e join dept d on e.dept_id = d.id where e.age &lt; 30;</span><br><span class="line"></span><br><span class="line">-- 3. 查询拥有员工的部门ID、部门名称</span><br><span class="line">select distinct d.id,d.name from emp e , dept d where e.dept_id = d.id;</span><br><span class="line"></span><br><span class="line">-- 4. 查询所有年龄大于40岁的员工, 及其归属的部门名称; 如果员工没有分配部门, 也需要展示出来</span><br><span class="line">select e.*,d.name from emp e left join dept d on e.dept_id = d.id where e.age &gt; 40;</span><br><span class="line"></span><br><span class="line">-- 5. 查询所有员工的工资等级</span><br><span class="line">select e.*,s.grade from emp e,salgrade s where e.salary &gt;= s.losal and e.salary &lt;= s.hisal;</span><br><span class="line">select e.*,s.grade from emp e,salgrade s where e.salary between s.losal and s.hisal;</span><br><span class="line"></span><br><span class="line">-- 6. 查询 &quot;研发部&quot; 所有员工的信息及 工资等级</span><br><span class="line">select e.*,d.name,s.grade</span><br><span class="line">from</span><br><span class="line">    emp e, dept d, salgrade s</span><br><span class="line">where</span><br><span class="line">    e.dept_id = d.id and e.salary between s.losal and s.hisal and d.name = &#x27;研发部&#x27;;</span><br><span class="line"></span><br><span class="line">-- 7. 查询 &quot;研发部&quot; 员工的平均工资</span><br><span class="line">select</span><br><span class="line">    avg(e.salary)</span><br><span class="line">from</span><br><span class="line">    emp e, dept d</span><br><span class="line">where</span><br><span class="line">    e.dept_id = d.id and</span><br><span class="line">    d.name = &#x27;研发部&#x27;;</span><br><span class="line"></span><br><span class="line">-- 8. 查询工资比 &quot;灭绝&quot; 高的员工信息。</span><br><span class="line">select</span><br><span class="line">    *</span><br><span class="line">from</span><br><span class="line">    emp e</span><br><span class="line">where</span><br><span class="line">    e.salary &gt; (select e.salary from emp e where e.name = &#x27;灭绝&#x27;);</span><br><span class="line"></span><br><span class="line">-- 9. 查询比平均薪资高的员工信息</span><br><span class="line">select</span><br><span class="line">    *</span><br><span class="line">from</span><br><span class="line">    emp</span><br><span class="line">where</span><br><span class="line">    salary &gt; (select avg(salary) from emp);</span><br><span class="line"></span><br><span class="line">-- 10. 查询低于本部门平均工资的员工信息</span><br><span class="line">select *</span><br><span class="line">from emp e1</span><br><span class="line">where</span><br><span class="line">    e1.salary &lt; (select avg(e.salary) from emp e where e.dept_id = e1.dept_id);</span><br><span class="line"></span><br><span class="line">-- 11. 查询所有的部门信息, 并统计部门的员工人数</span><br><span class="line">select d.*, (select count(*) from emp e where e.dept_id = d.id) &#x27;人数&#x27; from dept d;</span><br><span class="line"></span><br><span class="line">select d.id,d.name,count(e.id) from dept d left join emp e on d.id = e.dept_id group by d.id,d.name;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
